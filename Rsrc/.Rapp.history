nsum
lambda_vals = classe_params[grepl(pattern="lambda", x=names(classe_params))]#
	lambda_names = names(lambda_vals)
lambda_ijk_txt = gsub(pattern="lambda", replacement="", x=lambda_names)
k <= 9
lambda_ijk_mat = matrix(0.0, ncol=k, nrow=nsum)#
		is_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		ks_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=5, stop=6, USE.NAMES=FALSE))
is_vec
ks_vec
lambda_ijk_mat[,1] = as.numeric(is_vec)#
		lambda_ijk_mat[,2] = as.numeric(js_vec)#
		lambda_ijk_mat[,3] = as.numeric(ks_vec)
length(is_vec)
dim(lambda_ijk_mat)
nsum <- k * (k + 1)/2#
#
	# Convert the classe_params lambdas to a table#
	lambda_vals = classe_params[grepl(pattern="lambda", x=names(classe_params))]#
	lambda_names = names(lambda_vals)#
	# Get i, j, k indices#
	lambda_ijk_txt = gsub(pattern="lambda", replacement="", x=lambda_names)#
	if (k <= 9)#
		{#
		ijks_vector = unlist(sapply(X=lambda_ijk_txt, FUN=strsplit, split="", USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(as.numeric(ijks_vector), ncol=k, byrow=TRUE)#
		lambda_ijk_mat#
		} else {#
		# Split by 2#
		is_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		ks_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=5, stop=6, USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(cbind(is_vec, js_vec, ks_vec))#
		}#
	lambda_ijk_df = as.data.frame(cbind(lambda_ijk_mat, lambda_vals))#
	names(lambda_ijk_df) = c("i", "j", "k", "lambda")#
	return(lambda_ijk_df)#
	} # END classe_lambdas_to_df <- function(classe_params, k=3)
lambda_vals
length(lambda_vals)
is_vec
length(is_vec)
nsum <- k * (k + 1)/2#
#
	# Convert the classe_params lambdas to a table#
	lambda_vals = classe_params[grepl(pattern="lambda", x=names(classe_params))]#
	lambda_names = names(lambda_vals)#
	# Get i, j, k indices#
	lambda_ijk_txt = gsub(pattern="lambda", replacement="", x=lambda_names)#
	if (k <= 9)#
		{#
		ijks_vector = unlist(sapply(X=lambda_ijk_txt, FUN=strsplit, split="", USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(as.numeric(ijks_vector), ncol=k, byrow=TRUE)#
		lambda_ijk_mat#
		} else {#
		# Split by 2#
		is_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		ks_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=5, stop=6, USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(cbind(is_vec, js_vec, ks_vec))#
		}#
	lambda_ijk_df = as.data.frame(cbind(lambda_ijk_mat, lambda_vals))#
	names(lambda_ijk_df) = c("i", "j", "k", "lambda")
lambda_ijk_mat
# Number of lambdas per state (e.g., for 3 states, this is 6 lambdas per state#
	nsum <- k * (k + 1)/2#
#
	# Convert the classe_params lambdas to a table#
	lambda_vals = classe_params[grepl(pattern="lambda", x=names(classe_params))]#
	lambda_names = names(lambda_vals)#
	# Get i, j, k indices#
	lambda_ijk_txt = gsub(pattern="lambda", replacement="", x=lambda_names)#
	if (k <= 9)#
		{#
		ijks_vector = unlist(sapply(X=lambda_ijk_txt, FUN=strsplit, split="", USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(as.numeric(ijks_vector), ncol=k, byrow=TRUE)#
		lambda_ijk_mat#
		} else {#
		# Split by 2#
		is_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		ks_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=5, stop=6, USE.NAMES=FALSE))#
		lambda_ijk_mat = cbind(is_vec, js_vec, ks_vec)#
		}#
	lambda_ijk_df = as.data.frame(cbind(lambda_ijk_mat, lambda_vals))#
	names(lambda_ijk_df) = c("i", "j", "k", "lambda")
lambda_ijk_df
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)
library(BioGeoBEARS)#
trfn = "Psychotria_tree.newick"#
geogfn = "Psychotria_geog.data"#
max_range_size = 4#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
res = bears_optim_run(BioGeoBEARS_run_object)#
mats = get_Qmat_COOmat_from_res(res, numstates=NULL, include_null_range=TRUE, max_range_size=4, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)
head(lambda_ijk_df)
mats
length(mats$)Rsp_rowsums
length(mats$Rsp_rowsums)
mats = get_Qmat_COOmat_from_res(res, numstates=NULL, include_null_range=TRUE, max_range_size=4, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
# Calculate the per-event probabilities#
per_event_probs = rep(0.0, times=length(mats$Rsp_rowsums)+include_null_range)#
for (i in 1:length(mats$COO_weights_columnar[[1]]))#
	{#
	anc_state = mats$COO_weights_columnar[[1]][i] + 1 + include_null_range#
	left_state = mats$COO_weights_columnar[[2]][i] + 1 + include_null_range#
	right_state = mats$COO_weights_columnar[[3]][i] + 1 + include_null_range#
	sumWeights = mats$Rsp_rowsums[anc_state - include_null_range]#
	per_event_probs[anc_state] = per_event_probs[anc_state] + mats$COO_weights_columnar[[4]][i] / sumWeights#
	}#
#
per_event_probs
include_null_range = BioGeoBEARS_run_object$include_null_range
mats = get_Qmat_COOmat_from_res(res, numstates=NULL, include_null_range=TRUE, max_range_size=4, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
# Calculate the per-event probabilities#
per_event_probs = rep(0.0, times=length(mats$Rsp_rowsums)+include_null_range)#
for (i in 1:length(mats$COO_weights_columnar[[1]]))#
	{#
	anc_state = mats$COO_weights_columnar[[1]][i] + 1 + include_null_range#
	left_state = mats$COO_weights_columnar[[2]][i] + 1 + include_null_range#
	right_state = mats$COO_weights_columnar[[3]][i] + 1 + include_null_range#
	sumWeights = mats$Rsp_rowsums[anc_state - include_null_range]#
	per_event_probs[anc_state] = per_event_probs[anc_state] + mats$COO_weights_columnar[[4]][i] / sumWeights#
	}#
#
per_event_probs
mats = get_Qmat_COOmat_from_res(res, numstates=NULL, include_null_range=TRUE, max_range_size=4, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
# Calculate the per-event probabilities#
per_event_probs_totals = rep(0.0, times=length(mats$Rsp_rowsums)+include_null_range)#
per_event_probs = rep(0.0, times=length(mats$COO_weights_columnar[[4]]))#
for (i in 1:length(mats$COO_weights_columnar[[1]]))#
	{#
	anc_state = mats$COO_weights_columnar[[1]][i] + 1 + include_null_range#
	left_state = mats$COO_weights_columnar[[2]][i] + 1 + include_null_range#
	right_state = mats$COO_weights_columnar[[3]][i] + 1 + include_null_range#
	sumWeights = mats$Rsp_rowsums[anc_state - include_null_range]#
	per_event_probs[i] = mats$COO_weights_columnar[[4]][i] / sumWeights#
	per_event_probs_totals[anc_state] = per_event_probs[anc_state] + mats$COO_weights_columnar[[4]][i] / sumWeights#
	}#
#
per_event_probs
i = mats$COO_weights_columnar[[1]] + 1 + include_null_range#
j = mats$COO_weights_columnar[[2]] + 1 + include_null_range#
k = mats$COO_weights_columnar[[3]] + 1 + include_null_range#
wt = mats$COO_weights_columnar[[4]]#
prob = per_event_probs#
Carray_df = as.data.frame(cbind(i, j, k, wt, prob))#
head(Carray_df)#
tail(Carray_df)
get_Cevent_probs_df_from_mats <- function(mats, include_null_range=TRUE)#
	{#
	numstates = length(mats$states_list)#
#
	# Calculate the per-event probabilities#
	per_event_probs_totals = rep(0.0, times=length(mats$Rsp_rowsums)+include_null_range)#
	per_event_probs = rep(0.0, times=length(mats$COO_weights_columnar[[4]]))#
	for (i in 1:length(mats$COO_weights_columnar[[1]]))#
		{#
		anc_state = mats$COO_weights_columnar[[1]][i] + 1 + include_null_range#
		left_state = mats$COO_weights_columnar[[2]][i] + 1 + include_null_range#
		right_state = mats$COO_weights_columnar[[3]][i] + 1 + include_null_range#
		sumWeights = mats$Rsp_rowsums[anc_state - include_null_range]#
		per_event_probs[i] = mats$COO_weights_columnar[[4]][i] / sumWeights#
		per_event_probs_totals[anc_state] = per_event_probs[anc_state] + mats$COO_weights_columnar[[4]][i] / sumWeights#
		}#
#
	per_event_probs#
#
	i = mats$COO_weights_columnar[[1]] + 1 + include_null_range#
	j = mats$COO_weights_columnar[[2]] + 1 + include_null_range#
	k = mats$COO_weights_columnar[[3]] + 1 + include_null_range#
	wt = mats$COO_weights_columnar[[4]]#
	prob = per_event_probs#
	Carray_df = as.data.frame(cbind(i, j, k, wt, prob), stringsAsFactors=FALSE)#
	#head(Carray_df)#
	#tail(Carray_df)#
	return(Carray_df)#
	} # END get_Cevent_probs_from_mats <- function(mats, include_null_range=TRUE)
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)
res$inputs$include_null_range
res$inputs$max_range_size
names(res)
res$ML_marginal_prob_each_state_at_branch_top_AT_node
lambda_ijk_df
head(Carray_df)
head(lambda_ijk_df)
Carray_df
birthRate = 0.2#
for (r in nrow(lambda_ijk_df))#
	{#
	i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = Carray_df$prob[TF] + (Carray_df$prob[TF] * birthRate)#
		}#
	# Don't repeat the search when j==k (left and right states are the same)#
	if (j == k)#
		{#
		next()#
		}#
	# Repeat, switching j and k states#
	jTF = Carray_df$j == k#
	kTF = Carray_df$k == j#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = Carray_df$prob[TF] + (Carray_df$prob[TF] * birthRate)#
		} # END if (sum(TF) == 1)#
	} # END for (r in nrow(lambda_ijk_df))#
#
lambda_ijk_df$lambda
lambda_ijk_df
k
j
Carray_df$k
r=q
r=1
i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3
TF
i
j
k
Carray_df
lambda_ijk_df
tail(lambda_ijk_df)
lambda_ijk_df[]100,
lambda_ijk_df[100,]
lambda_ijk_df[80,]
lambda_ijk_df[200,]
lambda_ijk_df[150,]
lambda_ijk_df[160,]
lambda_ijk_df[155,]
lambda_ijk_df[152,]
lambda_ijk_df[153,]
r = 153
i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3
sum(TF)
lambda_ijk_df[lambda_ijk_df != 0]
lambda_ijk_df[lambda_ijk_df != 0,]
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)
lambda_ijk_df$lambda[r]
classe_lambdas_to_df <- function(classe_params, k=3)#
	{#
	ex='#
	k = 3#
	classe_params = c(lambda111 = 0.2, lambda112 = 0, lambda113 = 0, lambda122 = 0, #
lambda123 = 0, lambda133 = 0, lambda211 = 0, lambda212 = 0, lambda213 = 0, #
lambda222 = 0.2, lambda223 = 0, lambda233 = 0, lambda311 = 0, #
lambda312 = 0.0666666666666667, lambda313 = 0.0666666666666667, #
lambda322 = 0, lambda323 = 0.0666666666666667, lambda333 = 0, #
mu1 = 0.1, mu2 = 0.1, mu3 = 0.1, q12 = 0, q13 = 0, q21 = 0, q23 = 0, #
q31 = 0, q32 = 0)#
	lambda_ijk_df = classe_lambdas_to_df(classe_params=classe_params, k=3)#
	lambda_ijk_df#
	' # end example#
	# Number of lambdas per state (e.g., for 3 states, this is 6 lambdas per state#
	nsum <- k * (k + 1)/2#
#
	# Convert the classe_params lambdas to a table#
	lambda_vals = classe_params[grepl(pattern="lambda", x=names(classe_params))]#
	lambda_names = names(lambda_vals)#
	# Get i, j, k indices#
	lambda_ijk_txt = gsub(pattern="lambda", replacement="", x=lambda_names)#
	if (k <= 9)#
		{#
		ijks_vector = unlist(sapply(X=lambda_ijk_txt, FUN=strsplit, split="", USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(as.numeric(ijks_vector), ncol=k, byrow=TRUE)#
		lambda_ijk_mat#
		} else {#
		# Split by 2#
		is_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		ks_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=5, stop=6, USE.NAMES=FALSE))#
		lambda_ijk_mat = cbind(is_vec, js_vec, ks_vec)#
		}#
	lambda_ijk_df = as.data.frame(cbind(lambda_ijk_mat, lambda_vals))#
	lambda_ijk_df$lambda = as.numeric(lambda_ijk_df$lambda)#
	names(lambda_ijk_df) = c("i", "j", "k", "lambda")#
	return(lambda_ijk_df)#
	} # END classe_lambdas_to_df <- function(classe_params, k=3)
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)
# k= number of states#
# Note that diversitree classe includes only e.g. lambda123, not lambda 132#
classe_lambdas_to_df <- function(classe_params, k=3)#
	{#
	ex='#
	k = 3#
	classe_params = c(lambda111 = 0.2, lambda112 = 0, lambda113 = 0, lambda122 = 0, #
lambda123 = 0, lambda133 = 0, lambda211 = 0, lambda212 = 0, lambda213 = 0, #
lambda222 = 0.2, lambda223 = 0, lambda233 = 0, lambda311 = 0, #
lambda312 = 0.0666666666666667, lambda313 = 0.0666666666666667, #
lambda322 = 0, lambda323 = 0.0666666666666667, lambda333 = 0, #
mu1 = 0.1, mu2 = 0.1, mu3 = 0.1, q12 = 0, q13 = 0, q21 = 0, q23 = 0, #
q31 = 0, q32 = 0)#
	lambda_ijk_df = classe_lambdas_to_df(classe_params=classe_params, k=3)#
	lambda_ijk_df#
	' # end example#
	# Number of lambdas per state (e.g., for 3 states, this is 6 lambdas per state#
	nsum <- k * (k + 1)/2#
#
	# Convert the classe_params lambdas to a table#
	lambda_vals = classe_params[grepl(pattern="lambda", x=names(classe_params))]#
	lambda_names = names(lambda_vals)#
	# Get i, j, k indices#
	lambda_ijk_txt = gsub(pattern="lambda", replacement="", x=lambda_names)#
	if (k <= 9)#
		{#
		ijks_vector = unlist(sapply(X=lambda_ijk_txt, FUN=strsplit, split="", USE.NAMES=FALSE))#
		lambda_ijk_mat = matrix(as.numeric(ijks_vector), ncol=k, byrow=TRUE)#
		lambda_ijk_mat#
		} else {#
		# Split by 2#
		is_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		ks_vec = unlist(sapply(X=lambda_ijk_txt, FUN=substr, start=5, stop=6, USE.NAMES=FALSE))#
		lambda_ijk_mat = cbind(is_vec, js_vec, ks_vec)#
		}#
	lambda_ijk_df = as.data.frame(cbind(lambda_ijk_mat, lambda_vals))#
	names(lambda_ijk_df) = c("i", "j", "k", "lambda")#
	# Convert lambdas to numeric#
	lambda_ijk_df$lambda = as.numeric(lambda_ijk_df$lambda)#
	return(lambda_ijk_df)#
	} # END classe_lambdas_to_df <- function(classe_params, k=3)
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
for (r in nrow(lambda_ijk_df))#
	{#
	# r = 153#
	# lambda_ijk_df[153,]#
  #               i  j  k lambda#
	# lambda020202 02 02 02      0#
	i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = as.numericlambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		}#
	# Don't repeat the search when j==k (left and right states are the same)#
	if (j == k)#
		{#
		next()#
		}#
	# Repeat, switching j and k states#
	jTF = Carray_df$j == k#
	kTF = Carray_df$k == j#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		} # END if (sum(TF) == 1)#
	} # END for (r in nrow(lambda_ijk_df))#
#
lambda_ijk_df$lambda[lambda_ijk_df$lambda != 0,]
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
lambda_ijk_df$lambda
sum(lambda_ijk_df$lambda)
r
r=153
i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3
sum(TF)
as.numericlambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)
lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)
birthRate = 0.2#
for (r in nrow(lambda_ijk_df))#
	{#
	# r = 153#
	# lambda_ijk_df[153,]#
  #               i  j  k lambda#
	# lambda020202 02 02 02      0#
	i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		}#
	# Don't repeat the search when j==k (left and right states are the same)#
	if (j == k)#
		{#
		next()#
		}#
	# Repeat, switching j and k states#
	jTF = Carray_df$j == k#
	kTF = Carray_df$k == j#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		} # END if (sum(TF) == 1)#
	} # END for (r in nrow(lambda_ijk_df))#
#
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)
r=153
i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3
lambda_ijk_df$lambda[r]
lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)
lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
for (r in 1:nrow(lambda_ijk_df))#
	{#
	# r = 153#
	# lambda_ijk_df[153,]#
  #               i  j  k lambda#
	# lambda020202 02 02 02      0#
	i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		}#
	# Don't repeat the search when j==k (left and right states are the same)#
	if (j == k)#
		{#
		next()#
		}#
	# Repeat, switching j and k states#
	jTF = Carray_df$j == k#
	kTF = Carray_df$k == j#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		} # END if (sum(TF) == 1)#
	} # END for (r in nrow(lambda_ijk_df))#
#
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
for (r in 1:nrow(lambda_ijk_df))#
	{#
	# r = 153#
	# lambda_ijk_df[153,]#
  #               i  j  k lambda#
	# lambda020202 02 02 02      0#
	i = as.numeric(lambda_ijk_df$i[r])#
	j = as.numeric(lambda_ijk_df$j[r])#
	k = as.numeric(lambda_ijk_df$k[r])#
	iTF = Carray_df$i == i#
	jTF = Carray_df$j == j#
	kTF = Carray_df$k == k#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		}#
	# Don't repeat the search when j==k (left and right states are the same)#
	if (j == k)#
		{#
		next()#
		}#
	# Repeat, switching j and k states#
	jTF = Carray_df$j == k#
	kTF = Carray_df$k == j#
	TF = (iTF + jTF + kTF) == 3#
	if (sum(TF) == 1)#
		{#
		lambda_ijk_df$lambda[r] = lambda_ijk_df$lambda[r] + (Carray_df$prob[TF] * birthRate)#
		} # END if (sum(TF) == 1)#
	} # END for (r in nrow(lambda_ijk_df))#
#
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
lambda_ijk_df = get_Cevent_lambdas_from_BGB_Carray(lambda_ijk_df, Carray_df, birthRate=birthRate)#
lambda_ijk_df[lambda_ijk_df$lambda != 0,]
lambdas_to_put_in_params = rownames(lambda_ijk_df[lambda_ijk_df$lambda != 0,])#
lambdas_to_put_in_params
?find
?sort
?%in%
?%in%
match(x=names(classe_params), table=lambdas_to_put_in_params)
match(x=lambdas_to_put_in_params, table=names(classe_params))
lambdas_to_put_in_params
lambda_ijk_df[lambdas_to_put_in_params]
lambda_ijk_df[lambdas_to_put_in_params,]
lambda_ijk_df[lambdas_to_put_in_params,"lambda"]
lambda_ijk_df[lambdas_to_put_in_params,"lambda"]
lambdas_to_put_in_params = rownames(lambda_ijk_df[lambda_ijk_df$lambda != 0,])#
indices_in_classe_params = match(x=lambdas_to_put_in_params, table=names(classe_params))#
classe_params[indices_in_classe_params] = lambda_ijk_df[lambdas_to_put_in_params,"lambda"]
classe_params
classe_params[153]
classe_params["lambda060203"]
1/0.06666667
mats
0.06666667 / birthRate
classe_params
tail(classe_params)
# Convert the classe_params qs to a table#
	Q_vals = classe_params[grepl(pattern="q", x=names(classe_params))]#
	Q_names = names(Q_vals)#
	# Get i, j, k indices#
	Qij_txt = gsub(pattern="q", replacement="", x=Q_names)#
	if (k <= 9)#
		{#
		ijs_vector = unlist(sapply(X=Qij_txt, FUN=strsplit, split="", USE.NAMES=FALSE))#
		Qij_mat = matrix(as.numeric(ijs_vector), ncol=k, byrow=TRUE)#
		Qij_mat#
		} else {#
		# Split by 2#
		is_vec = unlist(sapply(X=Qij_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=Qij_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))#
		Qij_mat = cbind(is_vec, js_vec)#
		}#
	Qij_df = as.data.frame(cbind(Qij_mat, Q_vals))#
	names(Qij_df) = c("i", "j", "q")#
	# Convert qs to numeric#
	Qij_df$q = as.numeric(Qij_df$q)
Qij_df
names(mats)
mats$Qmat
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)
Qij_df = classe_Qs_to_df(classe_params, k=numstates)#
Qmat = mats$Qmat#
Qij_df = get_Qijs_from_BGB_Qarray(Qij_df, Qmat)
Qij_df
Qij_df[Qij_df$q != 0,]
Qij_df
head(Qij_df)
classe_params[grepl(pattern="mu", x=names(classe_params)]
classe_params[grepl(pattern="mu", x=names(classe_params))]
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)#
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q02q03"]
classe_params["q02q06"]
classe_params["q0206"]
classe_params["q0207"]
classe_params[classe_params != 0.0]
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
	numstates = length(mats$states_list)#
	include_null_range = res$include_null_range#
	# BioGeoBEARS Cevent weights into DF#
	Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
	# Diversitree params into a df#
	lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
	# Put the Cevent_weights * birthRate into diversitree table#
	lambda_ijk_df = get_Cevent_lambdas_from_BGB_Carray(lambda_ijk_df, Carray_df, birthRate=birthRate)#
	lambda_ijk_df[lambda_ijk_df$lambda != 0,]#
#
	# Convert the diversitree table back to classe_params#
	lambdas_to_put_in_params = rownames(lambda_ijk_df[lambda_ijk_df$lambda != 0,])#
	indices_in_classe_params = match(x=lambdas_to_put_in_params, table=names(classe_params))#
	classe_params[indices_in_classe_params] = lambda_ijk_df[lambdas_to_put_in_params,"lambda"]#
	classe_params[153]#
	classe_params["lambda020202"]#
	classe_params["lambda060203"]#
	# Now do the Qmat#
	Qij_df = classe_Qs_to_df(classe_params, k=numstates)#
	Qmat = mats$Qmat
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)#
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q0206"]#
classe_params[classe_params != 0.0]#
#
Qij_df = classe_Qs_to_df(classe_params, k=numstates)
BGBres_into_classe_params(res, classe_params, birthRate=0.2)
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)
length(mats$Rsp_rowsums)
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
	numstates = length(mats$states_list)#
	include_null_range = res$include_null_range#
	# BioGeoBEARS Cevent weights into DF#
	Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)
mats
mats$Rsp_rowsums
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)
numstates = length(mats$states_list)#
#
	# Calculate the per-event probabilities#
	num_event_totals = length(mats$Rsp_rowsums)+include_null_range#
	print(num_event_totals)
include_null_range
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)#
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q0206"]#
classe_params[classe_params != 0.0]
Qmat
classe_params[grepl(pattern="q", x=names(classe_params))]
Q_vals = classe_params[grepl(pattern="q", x=names(classe_params))]#
	Q_names = names(Q_vals)#
	# Get i, j, k indices#
	Qij_txt = gsub(pattern="q", replacement="", x=Q_names)
Qij_txt
is_vec = unlist(sapply(X=Qij_txt, FUN=substr, start=1, stop=2, USE.NAMES=FALSE))#
		js_vec = unlist(sapply(X=Qij_txt, FUN=substr, start=3, stop=4, USE.NAMES=FALSE))
Qij_mat = cbind(is_vec, js_vec)
Qij_mat
Qij_df = as.data.frame(cbind(Qij_mat, Q_vals))#
	names(Qij_df) = c("i", "j", "q")#
	# Convert qs to numeric#
	Qij_df$q = as.numeric(Qij_df$q)
Qij_df
Qij_df = get_Qijs_from_BGB_Qarray(Qij_df, Qmat)
Qij_df
classe_16states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# The names of the parameters:#
param_names = argnames(classe_16states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
	numstates = length(mats$states_list)#
	include_null_range = res$inputs$include_null_range#
	# BioGeoBEARS Cevent weights into DF#
	Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
	# Diversitree params into a df#
	lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
	# Put the Cevent_weights * birthRate into diversitree table#
	lambda_ijk_df = get_Cevent_lambdas_from_BGB_Carray(lambda_ijk_df, Carray_df, birthRate=birthRate)#
	lambda_ijk_df[lambda_ijk_df$lambda != 0,]#
#
	# Convert the diversitree table back to classe_params#
	lambdas_to_put_in_params = rownames(lambda_ijk_df[lambda_ijk_df$lambda != 0,])#
	indices_in_classe_params = match(x=lambdas_to_put_in_params, table=names(classe_params))#
	classe_params[indices_in_classe_params] = lambda_ijk_df[lambdas_to_put_in_params,"lambda"]#
	classe_params[153]#
	classe_params["lambda020202"]#
	classe_params["lambda060203"]
Qij_df = classe_Qs_to_df(classe_params, k=numstates)#
	Qmat = mats$Qmat
Qij_df
tail(Qij_df)
tail(Qij_df,100)
get_Qijs_from_BGB_Qarray(Qij_df, Qmat)
tail(get_Qijs_from_BGB_Qarray(Qij_df, Qmat),100)
Qmat
Qij_df
tail(get_Qijs_from_BGB_Qarray(Qij_df, Qmat),100)
nrow(v)
nrow(Qij_df)
Qij_df[224]
Qij_df[224,]
Qij_df[226,]
Qij_df[225,]
r=225
i = as.numeric(Qij_df$i[r])#
		j = as.numeric(Qij_df$j[r])
i
j
Qij_df$q[r] + Qmat[i,j]
for (r in 1:nrow(Qij_df))#
		{#
		# r = 153#
		# Qij_df[153,]#
		#               i  j  k lambda#
		# lambda020202 02 02 02      0#
		i = as.numeric(Qij_df$i[r])#
		j = as.numeric(Qij_df$j[r])#
		# Don't include the diagonals from Q#
		if (j == k)#
			{#
			next()#
			}#
#
		Qij_df$q[r] = Qij_df$q[r] + Qmat[i,j]#
		} # END for (r in nrow(Qij_df))#
#
	Qij_df[Qij_df$q != 0,]
r
r=225
Qij_df[r,]
Qij_df$q[r] = Qij_df$q[r] + Qmat[i,j]
Qij_df$q[r]
Qmat[i,j]
Qmat
Qmat[i,j]
i
j
Qij_txt
Qij_df
tail(Qij_df,100)
r
i = as.numeric(Qij_df$i[r])#
		j = as.numeric(Qij_df$j[r])
i
j
Qmat[i,j]
Qij_df$q[r]
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)#
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)
classe_params[153]
classe_params["q1516"]
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
	numstates = length(mats$states_list)#
	include_null_range = res$inputs$include_null_range#
	# BioGeoBEARS Cevent weights into DF#
	Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
	# Diversitree params into a df#
	lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
	# Put the Cevent_weights * birthRate into diversitree table#
	lambda_ijk_df = get_Cevent_lambdas_from_BGB_Carray(lambda_ijk_df, Carray_df, birthRate=birthRate)#
	lambda_ijk_df[lambda_ijk_df$lambda != 0,]#
#
	# Convert the diversitree table back to classe_params#
	lambdas_to_put_in_params = rownames(lambda_ijk_df[lambda_ijk_df$lambda != 0,])#
	indices_in_classe_params = match(x=lambdas_to_put_in_params, table=names(classe_params))#
	classe_params[indices_in_classe_params] = lambda_ijk_df[lambdas_to_put_in_params,"lambda"]#
	classe_params[153]#
	classe_params["lambda020202"]#
	classe_params["lambda060203"]#
	# Now do the Qmat#
	Qij_df = classe_Qs_to_df(classe_params, k=numstates)#
	Qmat = mats$Qmat#
	Qij_df = get_Qijs_from_BGB_Qarray(Qij_df, Qmat)
Qij_df
tail(Qij_df,100)
Qij_df = classe_Qs_to_df(classe_params, k=numstates)
Qij_df
tail(Qij_df,100)
Qij_df = classe_Qs_to_df(classe_params, k=numstates)
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)
Qij_df = classe_Qs_to_df(classe_params, k=numstates)
tail(Qij_df,100)
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names
Qij_df = classe_Qs_to_df(classe_params, k=numstates)
tail(Qij_df,100)
classe_Qs_to_df(classe_params, k=numstates)
tail(classe_Qs_to_df(classe_params, k=numstates), 100)
classe_Qs_to_df(classe_params, k=numstates)
Qij_df = classe_Qs_to_df(classe_params, k=numstates)#
	Qmat = mats$Qmat
Qmat
r=255
Qij_df[r,]
Qij_df
nrow(Qij_df)
r=226
Qij_df[r,]
r=225
Qij_df[r,]
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)#
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q0206"]#
classe_params["q1516"]#
classe_params[classe_params != 0.0]
Qij_df = classe_Qs_to_df(classe_params, k=numstates)#
Qmat = mats$Qmat#
Qij_df = get_Qijs_from_BGB_Qarray(Qij_df, Qmat)#
Qij_df[Qij_df$q != 0,]
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
########################################################
# BioGeoBEARS Q and C matrices#
########################################################
library(BioGeoBEARS)#
trfn = "Psychotria_tree.newick"#
geogfn = "Psychotria_geog.data"#
max_range_size = 4#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
include_null_range = BioGeoBEARS_run_object$include_null_range#
#
res = bears_optim_run(BioGeoBEARS_run_object)#
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)#
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
birthRate = 0.2#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=0.2)#
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q0206"]#
classe_params["q1516"]#
classe_params[classe_params != 0.0]
yule(tr)
res
res = bears_optim_run(BioGeoBEARS_run_object)#
mats = get_Qmat_COOmat_from_res(res, numstates=ncol(res$ML_marginal_prob_each_state_at_branch_top_AT_node), include_null_range=TRUE, max_range_size=res$inputs$max_range_size, timeperiod_i=1)#
numstates = length(mats$states_list)#
#
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)#
source('/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R', chdir = TRUE)#
Carray_df = get_Cevent_probs_df_from_mats(mats, include_null_range=include_null_range)#
head(Carray_df)#
tail(Carray_df)#
#
lambda_ijk_df = classe_lambdas_to_df(classe_params, k=numstates)#
head(lambda_ijk_df)#
#
# Put the Qmat and res parameter values from BioGeoBEARS "mats" into classe_params#
# Input some parameters#
yule(tr)#
#
birthRate = 0.3288164#
deathRate = 0.0#
d_val = 0.03505038#
e_val = 0.02832370#
j_val = 0.0#
#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=birthRate)#
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q0206"]#
classe_params["q1516"]#
classe_params[classe_params != 0.0]
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
#
# Fill in the params from the BioGeoBEARS "res" results#
classe_params = BGBres_into_classe_params(res, classe_params, birthRate=birthRate)#
classe_params[153]#
classe_params["lambda020202"]#
classe_params["lambda060203"]#
classe_params["q0206"]#
classe_params["q1516"]#
classe_params[classe_params != 0.0]
install.packages("rexpokit")
library(rexpokit)
library(devtools)#
devtools::install_github(repo="nmatzke/BioGeoBEARS", INSTALL_opts="--byte-compile")
install.packages("prettyunits")
library(prettyunits)
