M
M1
str(M1)
14105.354-14111.354
M2 <- lmer(formula = course ~ 1 + female + (1 | school), #
           data = GCSE, #
           REML = FALSE)#
summary(M2)
M1 <- lmer(formula = course ~ 1 + (1 | school), #
           data = GCSE, #
           REML = FALSE)#
summary(M1)
M1_stanlmer <- stan_lmer(formula = course ~ 1 + (1 | school), #
                         data = GCSE,#
                         seed = 349)
prior_summary(object = M1_stanlmer)
print(M1_stanlmer, digits = 2)
summary(M1_stanlmer, #
        pars = c("(Intercept)", "sigma", "Sigma[school:(Intercept),(Intercept)]"),#
        probs = c(0.025, 0.975),#
        digits = 2)
# Understanding Bayesian Inference with a simple example in R!#
# April 14, 2019#
# https://www.r-bloggers.com/understanding-bayesian-inference-with-a-simple-example-in-r/#
# Set the numer of tosses.#
n <- 100#
# Set the number of heads obtained.#
h <- 73#
#
# Define our likelihood function.#
# Since our model is a binomial model, we can use:#
likelihood <- function(h,n,p)#
	{#
	lh <- dbinom(h,n,p)#
	lh#
	}#
#
# Set the starting value of free parameter "p"#
p <- runif(1,0,1)#
#
# Create an empty data.frame to store the accepted p values for each iteration.#
# Remember: "the posterior probability is just an updated version of the prior"#
posterior <- data.frame()#
#
# Set the length of the loop (Markov Chain, number of iterations).#
nrep <- 5000#
#
# Start the loop (MCMC)#
for (i in 1:nrep)#
	{#
	# Obtain a new proposal value for p#
	p_prime <- p + runif(1, -0.05,0.05)#
#
	# Avoid values out of the range 0 - 1#
	if (p_prime < 0)#
		{#
		p_prime <- abs(p_prime)#
		}#
	if (p_prime > 1)#
		{#
		p_prime <- 2 - p_prime#
		}#
	# Compute the acceptance proability using our likelihood function and the#
	# beta(1,1) distribution as our prior probability.#
	R <- likelihood(h,n,p_prime)/likelihood(h,n,p) * (dbeta(p_prime,1,1)/dbeta(p,1,1))#
	# Accept or reject the new value of p#
	if (R > 1)#
		{#
		R <- 1#
		}#
	random <- runif (1,0,1)#
	if (random < R)#
		{#
		p <- p_prime#
		}#
	# Store the likelihood of the accepted p and its value#
	posterior[i,1] <- log(likelihood(h, n, p))#
	posterior[i,2] <- p#
	print(i)#
	}
# Understanding Bayesian Inference with a simple example in R!#
# April 14, 2019#
# https://www.r-bloggers.com/understanding-bayesian-inference-with-a-simple-example-in-r/#
# Set the numer of tosses.#
n <- 100#
# Set the number of heads obtained.#
h <- 73#
#
# Define our likelihood function.#
# Since our model is a binomial model, we can use:#
likelihood <- function(h,n,p)#
	{#
	lh <- dbinom(h,n,p)#
	lh#
	}#
#
# Set the starting value of free parameter "p"#
p <- runif(1,0,1)#
#
# Create an empty data.frame to store the accepted p values for each iteration.#
# Remember: "the posterior probability is just an updated version of the prior"#
posterior <- data.frame()#
#
# Set the length of the loop (Markov Chain, number of iterations).#
nrep <- 5000#
#
# Start the loop (MCMC)#
for (i in 1:nrep)#
	{#
	# Obtain a new proposal value for p#
	p_prime <- p + runif(1, -0.05,0.05)#
#
	# Avoid values out of the range 0 - 1#
	if (p_prime < 0)#
		{#
		p_prime <- abs(p_prime)#
		}#
	if (p_prime > 1)#
		{#
		p_prime <- 2 - p_prime#
		}#
	# Compute the acceptance proability using our likelihood function and the#
	# beta(1,1) distribution as our prior probability.#
	R <- likelihood(h,n,p_prime)/likelihood(h,n,p) * (dbeta(p_prime,1,1)/dbeta(p,1,1))#
	# Accept or reject the new value of p#
	if (R > 1)#
		{#
		R <- 1#
		}#
	random <- runif (1,0,1)#
	if (random < R)#
		{#
		p <- p_prime#
		}#
	# Store the likelihood of the accepted p and its value#
	posterior[i,1] <- log(likelihood(h, n, p))#
	posterior[i,2] <- p#
	cat(i, " ")#
	}
par(mfrow= c(1,2))#
prior <- rbeta(5000, 1,1)#
#
plot(1:5000 ,posterior$V2, cex=0, xlab = "generations", ylab = "p", main = "trace of MCMC\n accepted values of parameter p\n prior = beta(1,1) generations = 5000")
lines(1:5000, posterior$V2, cex=0)#
#
abline(h=mean(posterior$V2), col="red")
plot(density(posterior$V2), xlim = c(min(min(prior),min((posterior$V2))), max(max(prior),max((posterior$V2)))), ylim = c(0, max(max(density(prior)$y),max((density(posterior$V2)$y)))), main= "prior VS posterior\n prior= beta(1,1)", lwd=3, col="red")#
lines(density(prior), lwd=3, lty=2, col="blue")#
#
legend("topleft", legend=c("prior density","posterior density"),#
	 col=c("blue","red"), lty=c(3,1), lwd=c(3,3), cex = 1)
library(LaplacesDemon)
install.packages("LaplacesDemon")
library(LaplacesDemon)
pwd
?LaplacesDemon
data(demonsnacks)#
y <- log(demonsnacks$Calories)#
X <- cbind(1, as.matrix(log(demonsnacks[,c(1,4,10)]+1)))#
J <- ncol(X)#
for (j in 2:J) X[,j] <- CenterScale(X[,j])
demonsnacks
corplot(demonsnakcs)
corplot(demonsnacks)
pairs(demonsnacks)
pairs(log(demonsnacks))
?demonsnacks
snacks[,c(1,4,10)]+1
data(demonsnacks)#
snacks = demonsnacks
snacks[,c(1,4,10)]+1
# The predictors (serving size, saturated fat, and protein) will be stored in X#
# Also, we are taking the log (natural log)#
X <- cbind(1, as.matrix(log(snacks[,c(1,4,10)]+1)))#
J <- ncol(X)
library(LaplacesDemon)#
#
# Load some example data (nutritional info on snack packages, see ?demonsnacks)#
data(demonsnacks)#
snacks = demonsnacks#
#
# The thing you are trying to predict (amount of Calories) will be stored in "y"#
y <- log(snacks$Calories)#
#
# The predictors (serving size, saturated fat, and protein) will be stored in X#
# Also, we are taking the log (natural log)#
X <- cbind(1, as.matrix(log(snacks[,c(1,4,10)]+1)))#
#
# Center-Scale the variables#
for (j in 2:ncol(X))#
	{#
	X[,j] <- CenterScale(X[,j])#
	}
X
?CenterScale
library(LaplacesDemon)#
#
# Load some example data (nutritional info on snack packages, see ?demonsnacks)#
data(demonsnacks)#
snacks = demonsnacks#
#
# The thing you are trying to predict (amount of Calories) will be stored in "y"#
y <- log(snacks$Calories)#
#
# The predictors (serving size, saturated fat, and protein) will be stored in X#
# Also, we are taking the log (natural log)#
X <- cbind(1, as.matrix(log(snacks[,c(1,4,10)]+1)))#
#
# J is number of columns in X#
J = ncol(X)#
#
# Center-Scale the variables#
for (j in 2:J)#
	{#
	X[,j] <- CenterScale(X[,j])#
	}#
#########################  Data List Preparation  ##########################
mon.names <- "LP"#
parm.names <- as.parm.names(list(beta=rep(0,J), sigma=0))#
pos.beta <- grep("beta", parm.names)#
pos.sigma <- grep("sigma", parm.names)#
PGF <- function(Data) {#
     beta <- rnorm(Data$J)#
     sigma <- runif(1)#
     return(c(beta, sigma))#
     }#
MyData <- list(J=J, PGF=PGF, X=X, mon.names=mon.names,#
     parm.names=parm.names, pos.beta=pos.beta, pos.sigma=pos.sigma, y=y)
?PGF
mon.names <- "LP"#
parm.names <- as.parm.names(list(beta=rep(0,J), sigma=0))#
pos.beta <- grep("beta", parm.names)#
pos.sigma <- grep("sigma", parm.names)
parm.names
list(beta=rep(0,J), sigma=0)
?as.parm.names
PGF <- function(Data)#
	{#
	beta <- rnorm(Data$J)#
	sigma <- runif(1)#
	return(c(beta, sigma))#
	}#
MyData <- list(J=J, PGF=PGF, X=X, mon.names=mon.names,#
     parm.names=parm.names, pos.beta=pos.beta, pos.sigma=pos.sigma, y=y)
MyData
Model <- function(parm, Data)#
     {#
     ### Parameters#
     beta <- parm[Data$pos.beta]#
     sigma <- interval(parm[Data$pos.sigma], 1e-100, Inf)#
     parm[Data$pos.sigma] <- sigma#
     ### Log-Prior#
     beta.prior <- sum(dnormv(beta, 0, 1000, log=TRUE))#
     sigma.prior <- dhalfcauchy(sigma, 25, log=TRUE)#
     ### Log-Likelihood#
     mu <- tcrossprod(Data$X, t(beta))#
     LL <- sum(dnorm(Data$y, mu, sigma, log=TRUE))#
     ### Log-Posterior#
     LP <- LL + beta.prior + sigma.prior#
     Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP,#
          yhat=rnorm(length(mu), mu, sigma), parm=parm)#
     return(Modelout)#
     }
Initial.Values <- GIV(Model, MyData, PGF=TRUE)
Initial.Values
Fit <- LaplacesDemon(Model, Data=MyData, Initial.Values,#
    Covar=NULL, Iterations=1000, Status=100, Thinning=1,#
    Algorithm="MCMCMC", Specs=list(lambda=1, CPUs=2, Packages=NULL,#
    Dyn.libs=NULL))
Fi
Fit
Fit <- LaplacesDemon(Model, Data=MyData, Initial.Values,#
    Covar=NULL, Iterations=1000000, Status=100, Thinning=100,#
    Algorithm="MCMCMC", Specs=list(lambda=1, CPUs=2, Packages=NULL,#
    Dyn.libs=NULL))
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }
get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object)
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }
get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object)
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table
168*26.73
library(BioGeoBEARS)
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }
names(res)
29,747  /
29,747  / 25,867
29747  / 25867
28402 /  24698
123489 * 0.2
123489+107+1746
125342*0.2
86572 -  92303
26763 - 21226
8149.01	+ 8347.91+ 8552.94
25049.86-21226
26763-21226
5537+2138
5537+2191
7671 + 8348 + 8553 + 2191
120000 * 0.2 * 1.15
126000 * 0.2 * 1.15
7827.28-5537
28980-27600
7827.28-5537
2,138 ''
$86,572
$92,303
92303 / 86014
86572 / 75280
92303 / 82992
92303 / 80263
92303-86572
5731+2191
5731+2138
library(Rcpp)
library(RcppArmadillo)
.libPaths()
R.home('include')
library(rexpokit)
sessionInfo()
library(rexpokit)
sessionInfo()
?rexpokit
library(rexpokit)#
#
# Make a square instantaneous rate matrix (Q matrix)#
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide#
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,#
# Unleashed" at:#
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}#
##
# The Q matrix includes the stationary base freqencies, which Pmat#
# converges to as t becomes large.#
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504,#
0.168, 0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)#
#
# Make a series of t values#
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)#
#
# Exponentiate each with EXPOKIT's dgpadm (good for small dense matrices)#
for (t in tvals)#
	{#
	Pmat = expokit_dgpadm_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)#
	cat("\n\nTime=", t, "\n", sep="")#
	print(Pmat)#
	}#
#
# Exponentiate each with EXPOKIT's dmexpv (should be fast for large sparse matrices)#
for (t in tvals)#
	{#
	Pmat = expokit_dmexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)#
	cat("\n\nTime=", t, "\n", sep="")#
	print(Pmat)#
	}#
#
# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).#
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.#
#
# DMEXPV, single t-value#
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)#
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=2)#
#
# DGEXPV, single t-value#
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)#
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)#
#
# These functions runs the for-loop itself (sadly, we could not get mapply() to work#
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.#
#
# DMEXPV functions#
list_of_P_matrices_dmexpv = expokit_wrapalldmexpv_tvals(Qmat=Qmat,#
tvals=tvals, transpose_needed=TRUE)#
list_of_P_matrices_dmexpv#
#
# DGEXPV functions#
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,#
tvals=tvals, transpose_needed=TRUE)#
list_of_P_matrices_dgexpv#
#
# Check if there are differences in the results (might only happen for large problems)#
cat("\n")#
cat("Differences between dmexpv and dgexpv\n")#
#
for (i in 1:length(list_of_P_matrices_dmexpv))#
	{#
	diffs = list_of_P_matrices_dmexpv[[i]] - list_of_P_matrices_dgexpv[[i]]#
	print(diffs)#
	cat("\n")#
	}
?rexpokit
x <- matrix(1:25, nrow=5)/100#
#
expm(x)
library(rexpokit)
x <- matrix(1:25, nrow=5)/100#
#
expm(x)
?rexpokit
library(rexpokit)#
#
# Make a square instantaneous rate matrix (Q matrix)#
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide#
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,#
# Unleashed" at:#
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}#
##
# The Q matrix includes the stationary base freqencies, which Pmat#
# converges to as t becomes large.#
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504,#
0.168, 0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)#
#
# Make a series of t values#
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)#
#
# Exponentiate each with EXPOKIT's dgpadm (good for small dense matrices)#
for (t in tvals)#
	{#
	Pmat = expokit_dgpadm_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)#
	cat("\n\nTime=", t, "\n", sep="")#
	print(Pmat)#
	}
# Exponentiate each with EXPOKIT's dmexpv (should be fast for large sparse matrices)#
for (t in tvals)#
	{#
	Pmat = expokit_dmexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)#
	cat("\n\nTime=", t, "\n", sep="")#
	print(Pmat)#
	}#
#
# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).#
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.#
#
# DMEXPV, single t-value#
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)#
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=2)#
#
# DGEXPV, single t-value#
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)#
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)#
#
# These functions runs the for-loop itself (sadly, we could not get mapply() to work#
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.#
#
# DMEXPV functions#
list_of_P_matrices_dmexpv = expokit_wrapalldmexpv_tvals(Qmat=Qmat,#
tvals=tvals, transpose_needed=TRUE)#
list_of_P_matrices_dmexpv#
#
# DGEXPV functions#
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,#
tvals=tvals, transpose_needed=TRUE)#
list_of_P_matrices_dgexpv#
#
# Check if there are differences in the results (might only happen for large problems)#
cat("\n")#
cat("Differences between dmexpv and dgexpv\n")#
#
for (i in 1:length(list_of_P_matrices_dmexpv))#
	{#
	diffs = list_of_P_matrices_dmexpv[[i]] - list_of_P_matrices_dgexpv[[i]]#
	print(diffs)#
	cat("\n")#
	}
sessionInfo()
remove.packages("rexpokit")
library(rexpokit)
?rexpokit
library(rexpokit)#
#
# Make a square instantaneous rate matrix (Q matrix)#
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide#
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,#
# Unleashed" at:#
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}#
##
# The Q matrix includes the stationary base freqencies, which Pmat#
# converges to as t becomes large.#
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504,#
0.168, 0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)#
#
# Make a series of t values#
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)#
#
# Exponentiate each with EXPOKIT's dgpadm (good for small dense matrices)#
for (t in tvals)#
	{#
	Pmat = expokit_dgpadm_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)#
	cat("\n\nTime=", t, "\n", sep="")#
	print(Pmat)#
	}#
#
# Exponentiate each with EXPOKIT's dmexpv (should be fast for large sparse matrices)#
for (t in tvals)#
	{#
	Pmat = expokit_dmexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)#
	cat("\n\nTime=", t, "\n", sep="")#
	print(Pmat)#
	}#
#
# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).#
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.#
#
# DMEXPV, single t-value#
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)#
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=2)#
#
# DGEXPV, single t-value#
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)#
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)#
#
# These functions runs the for-loop itself (sadly, we could not get mapply() to work#
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.#
#
# DMEXPV functions#
list_of_P_matrices_dmexpv = expokit_wrapalldmexpv_tvals(Qmat=Qmat,#
tvals=tvals, transpose_needed=TRUE)#
list_of_P_matrices_dmexpv#
#
# DGEXPV functions#
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,#
tvals=tvals, transpose_needed=TRUE)#
list_of_P_matrices_dgexpv#
#
# Check if there are differences in the results (might only happen for large problems)#
cat("\n")#
cat("Differences between dmexpv and dgexpv\n")#
#
for (i in 1:length(list_of_P_matrices_dmexpv))#
	{#
	diffs = list_of_P_matrices_dmexpv[[i]] - list_of_P_matrices_dgexpv[[i]]#
	print(diffs)#
	cat("\n")#
	}
65/80
75/80
library(BioGeoBEARS)
bears_optim_run
# ClaSSE helper functions#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out
source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")
out
result_EsDs
result_EsDs = out[nrow(out), ]#
result_EsDs
paste0(result_EsDs)
paste0(result_EsDs, collapse=TRUE)
paste0(result_EsDs, collapse=" ")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
areas_list_to_states_list
relprob_vicar_matrix=relative_probabilities_of_vicariants(max_numareas=3, #
#' maxent_constraint_01v=0.0001)
)
library(BioGeoBEARS)
relprob_vicar_matrix=relative_probabilities_of_vicariants(max_numareas=3, maxent_constraint_01v=0.0001)
v
relprob_vicar_matrix
relative_probabilities_of_vicariants(max_numareas=3, maxent_constraint_01v=0.0001)
relative_probabilities_of_vicariants(max_numareas=3, maxent_constraint_01v=0.5)
relative_probabilities_of_vicariants(max_numareas=4, maxent_constraint_01v=0.5)
relative_probabilities_of_vicariants(max_numareas=5, maxent_constraint_01v=0.5)
relative_probabilities_of_vicariants(max_numareas=6, maxent_constraint_01v=0.5)
source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")
result_EsDs = [1 0.0860322055692215 0.0860322055692215 0 0.739232931655601]
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.02 # ML#
q10 = 0.01#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.2 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
mu0
mu1
bisse_params
seq()
times = seq(from=0, to=1, by=1/50)
times
times = seq(from=0, to=1, by=1/500)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out
tail(out)
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.05#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.05#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
# Set your working directory to wherever you unzipped this directory#
wd = "/GitHub/phyBEARS/ex/BiSSE_branchlikes_w_BD/"#
setwd(wd)#
library(ape)#
#
par(mfrow=c(2,1))#
tree_high_deathrate_fn = "tree_high_deathrate.newick"#
trstr = "(((chimp:1,human:1):1,gorilla:2):3,orang:5);"#
tree_high_deathrate = read.tree(file="", text=trstr)#
plot(tree_high_deathrate)#
axisPhylo()#
title("Tree with high deathRate")#
trfn = "tree.newick"#
trstr = "(((chimp:1,human:1):1,gorilla:2):1,orang:3);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
title("Tree with 0 deathRate")#
trfn = "tree_small.newick"#
tr = read.tree(file=trfn)#
plot(tr)#
axisPhylo()#
title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/phyBEARS/R/ClaSSE_mods_v1.R")#
#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(1, 1, 1)#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
#
LnLst = rbind(LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t)#
print(LnLst)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15069356 0.15069356 0.003615038 0.1672756#
# [5,] 0.08603219 0.08603219 0.001825474 0.1837656#
##
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15026899 0.15026899 0.003582702 0.1674394#
# [5,] 0.08566205 0.08566205 0.001808968 0.1839313#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [2,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [3,] 0.15069356 0.15069356 0.16483998 0.8351600#
# [4,]         NA         NA         NA        NA#
# [5,] 0.15069356 0.15069356 0.09868766 0.9013123#
# #
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08566205 0.08566205 0.08981508 0.9101849#
# [2,] 0.08566205 0.08566205 0.09063463 0.9093654#
# [3,] 0.15026899 0.15026899 0.16484005 0.8351599#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15026899 0.15026899 0.09780486 0.9021951#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [2,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [3,] 0.15069358 0.15069358 0.09311736 0.4717779#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15069357 0.15069357 0.01399609 0.1278260#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.2993006 -0.3021421 -0.5711150         NA -1.9499680#
# [1] -3.122526#
#
lq#
sum(lq)
tr
write.tree(file="")
write.tree(tr, file="")
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(2, 2, 2) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
#
LnLst = rbind(LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t)#
print(LnLst)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15069356 0.15069356 0.003615038 0.1672756#
# [5,] 0.08603219 0.08603219 0.001825474 0.1837656#
##
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15026899 0.15026899 0.003582702 0.1674394#
# [5,] 0.08566205 0.08566205 0.001808968 0.1839313#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [2,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [3,] 0.15069356 0.15069356 0.16483998 0.8351600#
# [4,]         NA         NA         NA        NA#
# [5,] 0.15069356 0.15069356 0.09868766 0.9013123#
# #
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08566205 0.08566205 0.08981508 0.9101849#
# [2,] 0.08566205 0.08566205 0.09063463 0.9093654#
# [3,] 0.15026899 0.15026899 0.16484005 0.8351599#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15026899 0.15026899 0.09780486 0.9021951#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [2,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [3,] 0.15069358 0.15069358 0.09311736 0.4717779#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15069357 0.15069357 0.01399609 0.1278260#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.2993006 -0.3021421 -0.5711150         NA -1.9499680#
# [1] -3.122526#
#
lq#
sum(lq)#
# [1] -0.3021421 -0.3021421 -0.5711149  0.0000000 -1.9531821#
# [1] -3.128581#
#
########################################################
########################################################
# END PROOF OF MATCHING
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
states
states = c(0,0,0) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15069356 0.15069356 0.003615038 0.1672756#
# [5,] 0.08603219 0.08603219 0.001825474 0.1837656#
##
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15026899 0.15026899 0.003582702 0.1674394#
# [5,] 0.08566205 0.08566205 0.001808968 0.1839313#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [2,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [3,] 0.15069356 0.15069356 0.16483998 0.8351600#
# [4,]         NA         NA         NA        NA#
# [5,] 0.15069356 0.15069356 0.09868766 0.9013123#
# #
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08566205 0.08566205 0.08981508 0.9101849#
# [2,] 0.08566205 0.08566205 0.09063463 0.9093654#
# [3,] 0.15026899 0.15026899 0.16484005 0.8351599#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15026899 0.15026899 0.09780486 0.9021951#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [2,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [3,] 0.15069358 0.15069358 0.09311736 0.4717779#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15069357 0.15069357 0.01399609 0.1278260#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.2993006 -0.3021421 -0.5711150         NA -1.9499680#
# [1] -3.122526#
#
lq#
sum(lq)
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
out
tr
plot(tr)
axisPhylo()
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
trdf
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
base[,3:4] * exp(lq)
x=base[,3:4] * exp(lq)
x[1,]
x[1,]*x[1,]
x[1,]*x[1,]*0.2222222
rowSums(base[,3:4])
x[1,]*x[1,]*0.2222222 / sum(x[1,]*x[1,]*0.2222222)
c(0.09868766, 0.9013123)
sum(c(0.09868766, 0.9013123))
sqrt(c(0.09868766, 0.9013123))
c(0.001825474, 0.1837656)
sqrt(c(0.001825474, 0.1837656))
init
y=c(0.09868766, 0.9013123)
y^2
y^2 * 0.22222222
y=c(0.09868766, 0.9013123)*0.2222222
y
y^2
z=init[5, 3:4]
z
z^0.5
z^0.5 / 0.2222222
z^0.5
x / z^0.5
x
x1= x[1,]
x / z^0.5
x1 / z^0.5
x1 / z
x1 / z^0.5
1/1.56815
base
init
z
z^0.5
z^0.5 / x1
y
y=base[1,3:4]
y
y^2
z/y
z^0.5/y
z
z/y^2
y^2 * 0.2222222
tmp1base
base
init
y
base[,3:4] / lq
base[,3:4] * exp(lq)
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
########################################################
# Compare ClaSSE and BiSSE calculations#
##
# E.g.:#
# diversitree versus plain-R#
# diversitree versus BioGeoBEARS+Yule+BFs#
# #
########################################################
#
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,2,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.0#
e_val = 0.0#
j_val = 0.2#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 4 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
classe_params[param_names=="lambda112"] = jprob * birthRate#
classe_params[param_names=="lambda121"] = jprob * birthRate#
classe_params[param_names=="lambda212"] = jprob * birthRate#
classe_params[param_names=="lambda221"] = jprob * birthRate#
#
# Subset sympatry for state AB#
classe_params[param_names=="lambda312"] = 1/6 * birthRate#
classe_params[param_names=="lambda321"] = 1/6 * birthRate#
classe_params[param_names=="lambda313"] = 1/6 * birthRate#
classe_params[param_names=="lambda331"] = 1/6 * birthRate#
classe_params[param_names=="lambda323"] = 1/6 * birthRate#
classe_params[param_names=="lambda332"] = 1/6 * birthRate#
#
classe_params_DEC = classe_params#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
LikDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
LnLst2 = cbind(LnLst, LikDiff, LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
tr2 = read.tree(file="", text="((f:0.037678,e:0.037678):0.101711,(d:0.114221,(c:0.087662,(b:0.005593,a:0.005593):0.082069):0.02656):0.025167);")
tr
tr2
plot(tr2)
axisPhylo()
