result_EsDs = [1 0.0860322055692215 0.0860322055692215 0 0.739232931655601]
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.02 # ML#
q10 = 0.01#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.2 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
mu0
mu1
bisse_params
seq()
times = seq(from=0, to=1, by=1/50)
times
times = seq(from=0, to=1, by=1/500)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out
tail(out)
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v1.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0 # ML#
q10 = 0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_v2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.05#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.05#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
##
# Example BiSSE calculation#
# result_EsDs_biSSE_1branch_pureBirth_bl1#
# (1 branch, pure birth, no Q transitions, branchlength=1)#
# #
##
# Run with:#
##
# source("/GitHub/BioGeoJulia.jl/test/biSSE_1branch_n2.R")#
# #
########################################################
# ClaSSE helper functions#
library(deSolve)  # for lsoda#
library(ape)#
library(diversitree)#
# library(rexpokit)#
# library(cladoRcpp)#
# library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.4#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = deathRate#
mu1 = deathRate#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(from=0, to=1, by=1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
tail(out)#
#
# The last values of "out" are:#
result_EsDs = out[nrow(out), ]#
result_EsDs#
#
txt = paste0(result_EsDs, collapse=" ")#
juliatxt = paste0("R_result_EsDs = [", txt, "]")#
cat("\n")#
cat("Output of this R script:")#
cat(juliatxt)#
cat("\n")
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1,1)#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
computed_likelihoods_at_each_node
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = birthRate#
lambda1 = birthRate#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.1 # ML#
q10 = 0.1#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15069356 0.15069356 0.003615038 0.1672756#
# [5,] 0.08603219 0.08603219 0.001825474 0.1837656#
##
#            [,1]       [,2]        [,3]      [,4]#
# [1,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [2,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [3,] 0.00000000 0.00000000 0.000000000 1.0000000#
# [4,] 0.15026899 0.15026899 0.003582702 0.1674394#
# [5,] 0.08566205 0.08566205 0.001808968 0.1839313#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [2,] 0.08603219 0.08603219 0.09063462 0.9093654#
# [3,] 0.15069356 0.15069356 0.16483998 0.8351600#
# [4,]         NA         NA         NA        NA#
# [5,] 0.15069356 0.15069356 0.09868766 0.9013123#
# #
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08566205 0.08566205 0.08981508 0.9101849#
# [2,] 0.08566205 0.08566205 0.09063463 0.9093654#
# [3,] 0.15026899 0.15026899 0.16484005 0.8351599#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15026899 0.15026899 0.09780486 0.9021951#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#            [,1]       [,2]       [,3]      [,4]#
# [1,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [2,] 0.08603219 0.08603219 0.06700011 0.6722329#
# [3,] 0.15069358 0.15069358 0.09311736 0.4717779#
# [4,] 0.00000000 0.00000000 0.00000000 0.0000000#
# [5,] 0.15069357 0.15069357 0.01399609 0.1278260#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.2993006 -0.3021421 -0.5711150         NA -1.9499680#
# [1] -3.122526#
#
lq#
sum(lq)
computed_likelihoods_at_each_node
total_likelihood_for_node
computed_likelihoods_at_each_node_x_lambda
sum(log(computed_likelihoods_at_each_node_x_lambda))
sum(log(computed_likelihoods_at_each_node))
sum(log(computed_likelihoods_at_each_node_x_lambda)) - 2*log(0.2222222)
computed_likelihoods_at_each_node
sum(log(computed_likelihoods_at_each_node_x_lambda)) - 2*log(0.2222222)
sum(log(computed_likelihoods_at_each_node))
rootstates_lnL
LnLs1
?make.bisse
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)
bisse_2areas
fit.mle()
find.mle()
?find.mle()
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
fit <- find.mle(lik=bisse_2areas, x.init=bisse_params, method="subplex")
fit <- find.mle(func=bisse_2areas, x.init=bisse_params, method="subplex")
?constraint
?constrain
constrain(func=bisse_2areas, lambda0~lambda1, mu0=0.0, mu1=0.0, q01=1.0, q10=1.0)
constraints = list(lambda0~lambda1, mu0~0.0, mu1~0.0, q01~1.0, q10~1.0)#
constrain(func=bisse_2areas, formulae=constraints)
constrain(f=bisse_2areas, formulae=constraints)
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.0#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.0#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~0.0, mu1~0.0, q01~1.0, q10~1.0)#
constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 10 seconds#
fit <- find.mle(func=bisse_2areas, x.init=bisse_params, method="subplex")
fit
bisse_params
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 10 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")
fit
constraints = list(lambda0~lambda1, mu0~0.0, mu1~0.0, q01~0.0, q10~0.0)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 10 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")
fit
tr
yule(tr)
names(fit)
fit$par
fit$par.full
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
#
# Compare to Yule#
yule(tr)#
#
bisse_params_orig = bisse_params#
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
yule(tr)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)
yule(tr)#
#
bisse_params_orig = bisse_params#
bisse_params = fit$par.full
names(fit)
fit$lnLik
?find.mle
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", root=ROOT.OBS)
defaults = list(root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", defaults=defaults)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", condition.surv=FALSE)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, condition.surv=FALSE)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, list(condition.surv=FALSE))
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", list(condition.surv=FALSE))
fit
defaults = list(root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", defaults)
defaults = list(root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex", list(root=ROOT.OBS), list(condition.surv=FALSE))
fit
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
bisse_2areas_constrained2 = bisse_2areas_constrained(root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)
bisse_2areas_constrained2 = bisse_2areas_constrained(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)
bisse_params
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params[1], method="subplex")
fit$logLike
fit$logLik
names(fit)
fit$lnLik
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params[1], method="subplex", condition.surv=FALSE)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params[1], method="subplex")#
fit$par.full#
fit$lnLik
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.0#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.0#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~0.0, mu1~0.0, q01~0.0, q10~0.0)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 1 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params[1], method="subplex")#
fit$par.full#
fit$lnLik#
#
# Compare to Yule#
yule(tr)#
#
bisse_params_orig = bisse_params#
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
bisse_params
bisse_params$lambda0
bisse_params["lambda0"]
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)
lq#
sum(lq)
LnLs1t
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
bisse_params
yule(tr)
yule(tr)$loglik
yule(tr)$loglik + -2.609438
-5.828748 - v
-5.828748 - -4.525729
exp(-1.303019#
)
log(0.2)
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.0#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.0#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 1 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params[1], method="subplex")#
fit$par.full#
fit$lnLik
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params[1], method="subplex")#
fit$par.full
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
fit$par.full#
fit$lnLik
states = c(0, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 1 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
fit$par.full#
fit$lnLik
yule(tr)#
#
bisse_params_orig = bisse_params#
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.1999566 -0.1999566 -0.3999132         NA -1.8096115#
sum(lnls, na.rm=TRUE)
sum(log(computed_likelihoods_at_each_node_x_lambda))
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.1#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.1#
q10 = 0.1#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 1 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
fit$par.full#
fit$lnLik#
#
# Compare to Yule#
yule(tr)#
#
bisse_params_orig = bisse_params#
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
# condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#              [,1]         [,2]       [,3]       [,4]#
# [1,] 0.000000e+00 0.000000e+00 1.00000000 0.00000000#
# [2,] 0.000000e+00 0.000000e+00 0.00000000 1.00000000#
# [3,] 0.000000e+00 0.000000e+00 0.00000000 1.00000000#
# [4,] 1.488113e-13 1.488113e-13 0.05000001 0.05000002#
# [5,] 8.182151e-14 8.182151e-14 0.05000002 0.05000002#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 1.0000000#
# [2,]    0    0    0 1.0000000#
# [3,]    0    0    0 1.0000000#
# [4,]    0    0    0 0.2000001#
# [5,]    0    0    0 0.2000001#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#              [,1]         [,2] [,3] [,4]#
# [1,] 8.182151e-14 8.182151e-14  0.5  0.5#
# [2,] 8.182151e-14 8.182151e-14  0.5  0.5#
# [3,] 1.488113e-13 1.488113e-13  0.5  0.5#
# [4,]           NA           NA   NA   NA#
# [5,] 1.488113e-13 1.488113e-13  0.5  0.5#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3] [,4]#
# [1,]    0    0    0    1#
# [2,]    0    0    0    1#
# [3,]    0    0    0    1#
# [4,]    0    0    0    0#
# [5,]    0    0    0    1#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 0.8187307#
# [2,]    0    0    0 0.8187307#
# [3,]    0    0    0 0.6703200#
# [4,]    0    0    0 0.0000000#
# [5,]    0    0    0 0.1637462#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# -0.2000001 -0.2000001 -0.4000001         NA -1.8094377#
sum(lnls, na.rm=TRUE)#
# [1] -2.609438#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -0.1999566 -0.1999566 -0.3999132  0.0000000 -1.8096115#
# [1] -2.609438#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1t#
# -2.609438 -2.609438#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))#
# -5.828748#
R_result_branch_lnL = -2.609438#
R_result_total_lnL = -2.609438#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = -5.828748#
########################################################
########################################################
# END PROOF OF MATCHING
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
lq
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)
lq#
sum(lq)
LnLs1t
LnLs1
bisse_params
bisse_params["q10"]
sum(log(computed_likelihoods_at_each_node_x_lambda))
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 1.2#
#
lambda0 = birthRate*2#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate*2#
q01 = 0.4#
q10 = 0.2#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
# constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
# bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
# #
# Wait 1 seconds#
# fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
# fit$par.full#
# fit$lnLik#
# #
# Compare to Yule#
# yule(tr)#
# #
# bisse_params_orig = bisse_params#
# bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
# condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#              [,1]         [,2]       [,3]       [,4]#
# [1,] 0.000000e+00 0.000000e+00 1.00000000 0.00000000#
# [2,] 0.000000e+00 0.000000e+00 0.00000000 1.00000000#
# [3,] 0.000000e+00 0.000000e+00 0.00000000 1.00000000#
# [4,] 1.488113e-13 1.488113e-13 0.05000001 0.05000002#
# [5,] 8.182151e-14 8.182151e-14 0.05000002 0.05000002#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 1.0000000#
# [2,]    0    0    0 1.0000000#
# [3,]    0    0    0 1.0000000#
# [4,]    0    0    0 0.2000001#
# [5,]    0    0    0 0.2000001#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#              [,1]         [,2] [,3] [,4]#
# [1,] 8.182151e-14 8.182151e-14  0.5  0.5#
# [2,] 8.182151e-14 8.182151e-14  0.5  0.5#
# [3,] 1.488113e-13 1.488113e-13  0.5  0.5#
# [4,]           NA           NA   NA   NA#
# [5,] 1.488113e-13 1.488113e-13  0.5  0.5#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3] [,4]#
# [1,]    0    0    0    1#
# [2,]    0    0    0    1#
# [3,]    0    0    0    1#
# [4,]    0    0    0    0#
# [5,]    0    0    0    1#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 0.8187307#
# [2,]    0    0    0 0.8187307#
# [3,]    0    0    0 0.6703200#
# [4,]    0    0    0 0.0000000#
# [5,]    0    0    0 0.1637462#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# -0.2000001 -0.2000001 -0.4000002         NA -2.5025850#
sum(lnls, na.rm=TRUE)#
# [1] -3.302585#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -0.1999566 -0.1999566 -0.3999132  0.0000000 -1.8096115#
# -3.302585#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# -6.298317 -3.302585#
#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# -4.688879 -3.302585#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
# -7.907755#
R_result_branch_lnL = -3.302585#
R_result_total_LnLs1 = -6.298317#
R_result_total_LnLs1t = -4.688879#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = -7.907755#
########################################################
########################################################
# END PROOF OF MATCHING
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 0, 0) # 3 states for 3 tips#
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.0#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.0#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
constraints = list(lambda0~lambda1, mu0~0.0, mu1~0.0, q01~0.0, q10~0.0)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
#
# Wait 1 seconds#
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
fit$par.full#
fit$lnLik#
#
# Compare to Yule#
yule(tr)#
#
bisse_params_orig = bisse_params#
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 1.0000000#
# [2,]    0    0    0 1.0000000#
# [3,]    0    0    0 1.0000000#
# [4,]    0    0    0 0.1999566#
# [5,]    0    0    0 0.1999566#
# > condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 1.0000000#
# [2,]    0    0    0 1.0000000#
# [3,]    0    0    0 1.0000000#
# [4,]    0    0    0 0.1999566#
# [5,]    0    0    0 0.1999566#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3] [,4]#
# [1,]    0    0    0    1#
# [2,]    0    0    0    1#
# [3,]    0    0    0    1#
# [4,]   NA   NA   NA   NA#
# [5,]    0    0    0    1#
# > condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3] [,4]#
# [1,]    0    0    0    1#
# [2,]    0    0    0    1#
# [3,]    0    0    0    1#
# [4,]    0    0    0    0#
# [5,]    0    0    0    1#
#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#      [,1] [,2] [,3]      [,4]#
# [1,]    0    0    0 0.8187663#
# [2,]    0    0    0 0.8187663#
# [3,]    0    0    0 0.6703782#
# [4,]    0    0    0 0.0000000#
# [5,]    0    0    0 0.1637177#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.1999566 -0.1999566 -0.3999132         NA -1.8096115#
sum(lnls, na.rm=TRUE)#
# [1] -2.609438#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -0.1999566 -0.1999566 -0.3999132  0.0000000 -1.8096115#
# [1] -2.609438#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1t#
# -2.609438 -2.609438#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))#
# -5.828748#
R_result_branch_lnL = -2.609438#
R_result_total_lnL = -2.609438#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = -5.828748#
########################################################
########################################################
# END PROOF OF MATCHING
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}
SPCmod
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms)
out
plot(times, out$P)
plot(times, out["P"])
plot(times, out[,"P"])
points(times, out[,"C"], col="blue")
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")
states = c(1, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states
states = c(0, 0, 0) # 3 binary states for 3 tips#
states = c(1, 1, 1) # 3 binary states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 0.0#
#
lambda0 = birthRate#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate#
q01 = 0.0#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms
constraints = list(lambda0~lambda1, mu0~0.0, mu1~0.0, q01~0.0, q10~0.0)#
bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")
fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
fit$par.full#
fit$lnLik
yule(tr)
bisse_params_orig = bisse_params#
bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)
base[,34]
base[,3:4]
base[,3:4] * lq
exp(base[,3:4] * lq)
0.2 * 0.8187663
lq
sum(lq)
log(0.5)
log(0.5)+sum(lq)
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result
t
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=2, y=y, parms=parms)#
one_step_result
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out
lq
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)
condlikes_of_each_treeState_BRANCHTOP_AT_NODE
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE
condlikes_of_each_treeState_BRANCHTOP_AT_NODE
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])
relative_probs_of_each_state_BRANCHTOP_AT_NODE
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)
computed_likelihoods_at_each_node
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node
computed_likelihoods_at_each_node
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node
computed_likelihoods_at_each_node_x_lambda
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1
edges_to_visit
tr
names(tr)
tr$edge
prt(tr)
edges_to_visit
tr
tr$edge
tr2$edge
tr$edge.length
init
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = 0#
mu1 = 0#
# Character transition#
q01 = 0.0 # ML#
q10 = 0.0#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# [1] -0.1999566 -0.1999566 -0.3999132         NA -1.8096115#
sum(lnls, na.rm=TRUE)#
# [1] -2.609438#
# Sum of the branch likelihoods#
lq#
sum(lq)
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
base[,3:4] * lq#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
base[,3:4] * exp(lq)#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]
rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4])
log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)
lq#
sum(lq)
LnLs1t#
# -2.609438 -2.609438#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 1.2#
#
lambda0 = birthRate*2#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate*2#
q01 = 0.4#
q10 = 0.2#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
# constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
# bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
# #
# Wait 1 seconds#
# fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
# fit$par.full#
# fit$lnLik#
# #
# Compare to Yule#
# yule(tr)#
# #
# bisse_params_orig = bisse_params#
# bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
#           [,1]      [,2]      [,3]        [,4]#
# [1,] 0.0000000 0.0000000 1.0000000 0.000000000#
# [2,] 0.0000000 0.0000000 0.0000000 1.000000000#
# [3,] 0.0000000 0.0000000 0.0000000 1.000000000#
# [4,] 0.8988459 0.9775416 0.2597286 0.009541766#
# [5,] 0.6888798 0.8799765 0.1518462 0.015528271#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#           [,1]      [,2]       [,3]       [,4]#
# [1,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [2,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [3,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [4,] 0.8988459 0.9775416 0.20907825 0.02186927#
# [5,] 0.6888798 0.8799766 0.06604511 0.08391649#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]      [,3]      [,4]#
# [1,] 0.6888798 0.8799765 0.8862882 0.1137118#
# [2,] 0.6888798 0.8799765 0.3854885 0.6145115#
# [3,] 0.8988459 0.9775416 0.6725996 0.3274004#
# [4,]        NA        NA        NA        NA#
# [5,] 0.8988459 0.9775416 0.8688519 0.1311481#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]      [,3]      [,4]#
# [1,] 0.6888798 0.8799766 0.3854886 0.6145114#
# [2,] 0.6888798 0.8799766 0.3854886 0.6145114#
# [3,] 0.8988459 0.9775416 0.6725994 0.3274006#
# [4,] 0.0000000 0.0000000 0.0000000 0.0000000#
# [5,] 0.8988459 0.9775416 0.6994149 0.3005851#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]       [,3]        [,4]#
# [1,] 0.6888798 0.8799766 0.05141641 0.081963417#
# [2,] 0.6888798 0.8799766 0.05141641 0.081963417#
# [3,] 0.8988459 0.9775416 0.01959357 0.009537547#
# [4,] 0.0000000 0.0000000 0.00000000 0.000000000#
# [5,] 0.8988459 0.9775416 0.02373981 0.010202572#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# -1.526391 -2.014554 -3.535949  0.000000 -3.012482#
sum(lnls, na.rm=TRUE)#
# -10.08938#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -1.526391 -2.014554 -3.535949  0.000000 -3.012482#
# -10.08938#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# -11.47222 -10.08938#
#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# -6.043899 -10.089376#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
log(computed_likelihoods_at_each_node_x_lambda)
computed_likelihoods_at_each_node_x_lambda
parms
exp(-3.3629410089543565)
computed_likelihoods_at_each_node_x_lambda
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS
c(lambda0, lambda1) * D_relprobs_multiplied
-3.3629410089543565 - -3.0995610530035504
x = -3.3629410089543565 - -3.0995610530035504
exp(x)
root_stateprobs
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 1.2#
#
lambda0 = birthRate*2#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate*2#
q01 = 0.4#
q10 = 0.2#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
# constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
# bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
# #
# Wait 1 seconds#
# fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
# fit$par.full#
# fit$lnLik#
# #
# Compare to Yule#
# yule(tr)#
# #
# bisse_params_orig = bisse_params#
# bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,numstates] = 2	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
#           [,1]      [,2]      [,3]        [,4]#
# [1,] 0.0000000 0.0000000 1.0000000 0.000000000#
# [2,] 0.0000000 0.0000000 0.0000000 1.000000000#
# [3,] 0.0000000 0.0000000 0.0000000 1.000000000#
# [4,] 0.8988459 0.9775416 0.2597286 0.009541766#
# [5,] 0.6888798 0.8799765 0.1518462 0.015528271#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#           [,1]      [,2]       [,3]       [,4]#
# [1,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [2,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [3,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [4,] 0.8988459 0.9775416 0.20907825 0.02186927#
# [5,] 0.6888798 0.8799766 0.06604511 0.08391649#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]      [,3]      [,4]#
# [1,] 0.6888798 0.8799765 0.8862882 0.1137118#
# [2,] 0.6888798 0.8799765 0.3854885 0.6145115#
# [3,] 0.8988459 0.9775416 0.6725996 0.3274004#
# [4,]        NA        NA        NA        NA#
# [5,] 0.8988459 0.9775416 0.8688519 0.1311481#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]      [,3]      [,4]#
# [1,] 0.6888798 0.8799766 0.3854886 0.6145114#
# [2,] 0.6888798 0.8799766 0.3854886 0.6145114#
# [3,] 0.8988459 0.9775416 0.6725994 0.3274006#
# [4,] 0.0000000 0.0000000 0.0000000 0.0000000#
# [5,] 0.8988459 0.9775416 0.6994149 0.3005851#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]       [,3]        [,4]#
# [1,] 0.6888798 0.8799766 0.05141641 0.081963417#
# [2,] 0.6888798 0.8799766 0.05141641 0.081963417#
# [3,] 0.8988459 0.9775416 0.01959357 0.009537547#
# [4,] 0.0000000 0.0000000 0.00000000 0.000000000#
# [5,] 0.8988459 0.9775416 0.02373981 0.010202572#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# -1.526391 -2.014554 -3.535949  0.000000 -3.012482#
sum(lnls, na.rm=TRUE)#
# -10.08938#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -1.526391 -2.014554 -3.535949  0.000000 -3.012482#
# -10.08938#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# -11.47222 -10.08938#
#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# -6.043899 -10.089376#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
# -14.31109#
R_result_branch_lnL = -10.08938#
R_result_total_LnLs1 = -11.47222#
R_result_total_LnLs1t = -6.043899#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = -14.31109#
########################################################
########################################################
# END PROOF OF MATCHING
########################################################
# #
# This script demonstrates how BiSSE is calculated#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent BiSSE model#
##
# 4. BiSSE likelihoods and comparison to DEC#
# #
########################################################
#
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
# plot(tr)#
# axisPhylo()#
# title("Tree with 3 taxa")#
########################################################
########################################################
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
########################################################
########################################################
library(diversitree)#
library(deSolve)		# for lsoda#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
########################################################
# BiSSE directly, using lsoda#
########################################################
#
########################################################
# Example lsoda run#
########################################################
#
# Define the function#
#
# INPUTS#
# t = current time point in integration#
# y = current estimate of the variables in the system#
#     (if names(y) exists, those variables will be available)#
# parms = parameters (named)#
##
# OUTPUTS:#
# The return value of func should be a list, whose first element #
# is a vector containing the derivatives of y with respect to time, #
# and whose next elements are global values that are required at each #
# point in times. The derivatives must be specified in the same order #
# as the state variables y.#
# #
SPCmod <- function(t, x, parms)#
	{#
	with(data=#
	as.list(c(parms, x)), #
		{ # expr#
		import <- sigimp(t)#
		dS <- import - b*S*P + g*C     # substrate#
		dP <- c*S*P  - d*C*P           # producer#
		dC <- e*P*C  - f*C             # consumer#
		res <- c(dS, dP, dC)#
		list(res)#
		}#
	)#
	}#
#
## Parameters #
parms  <- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)#
#
## vector of timesteps#
times  <- seq(0, 100, length = 101)#
#
## external signal with rectangle impulse#
signal <- as.data.frame(list(times = times,#
                            import = rep(0,length(times))))#
#
signal$import[signal$times >= 10 & signal$times <= 11] <- 0.2#
#
sigimp <- approxfun(signal$times, signal$import, rule = 2)#
## Start values for steady state#
y <- xstart <- c(S = 1, P = 1, C = 1)#
#
## Solving#
out <-  lsoda(xstart, times, SPCmod, parms) #
########################################################
########################################################
# 2. Calculation of tree likelihood under a BirthDeath process#
########################################################
########################################################
library(ape)#
#trfn = "tree_small.newick"#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
plot(tr)#
axisPhylo()#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
# -3.216395#
# Set birthRate#
#birthRate = 0.22222222222222222222#
########################################################
# Likelihood equation in the birthdeath function#
########################################################
N <- length(tr$tip.label)#
nb_node = tr$Nnode - 1#
sptimes <- c(NA, branching.times(tr)) # NA so the number of times equals number of tips?#
# a = "d/b"#
# r = "b-d"#
#
dev <- function(a=0.1, r=0.2, N, x, return_deviance=FALSE)#
	{#
	if (r < 0 || a > 1) #
		return(1e+100)#
	lnl_topology = lfactorial(tr$Nnode)#
	lnl_numBirths = nb_node * log(r)#
	lnl_Births_above_root = r * sum(sptimes[3:N])#
	lnl_numtips_wOneMinusDeathRate = N * log(1 - a)#
	# Interpretation: more tips are less likely, if relativeDeathRate is >0#
	# If relativeDeathRate = 1, a=0, and lnl=-Inf... #
	#    CLEARLY WRONG EXCEPT IN A MAXIMUM LIKELIHOOD CONTEXT!!!#
	# If relativeDeathRate = 0, a=0, and lnl=0, i.e. any number of tips is equiprobable#
	lnl_branching_times = -2 * sum(log(exp(r * sptimes[2:N]) - a))#
	# For each observed branching,#
	# netDiversificationRate * timeOfEvent <- take exponent of that ; this means recorded events are less likely in the past#
	# <- subtract "a", a constant (relativeDeathRate)#
	##
	# This would be a straight likelihood as:#
	# 1/#
	# (exp(r*branching_time)-a)^2#
	##
	# Sum the logs of these#
	##
	# If deathRate = 0#
	# lnl_branching_times = -2 * sum(log(exp(birthRate*sptimes[2:N]) - 0))#
	# lnl_branching_times = -2 * sum(log( exp(birthRate*sptimes[2:N]) )#
	# lnl_branching_times = -2 * sum( birthRate*sptimes[2:N] )#
	##
	# Note: sum(X) = 9 = total branchlength of tr#
	# In BD:#
	# -2*sum(sptimes[2:N]) = -12#
	# sum(sptimes[3:N]) = 3#
	# So, lnl_branching_times + lnl_Births_above_root = yule's -lambda * X#
	if (return_deviance == TRUE)#
		{#
		result = -2 * (lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times)#
		} else {#
		result = lnl_topology + lnl_numBirths + lnl_Births_above_root + #
			lnl_numtips_wOneMinusDeathRate + lnl_branching_times#
		}#
	return(result)#
	}#
dev(a=0.1, r=0.2, N=N, x=x)#
# -4.063987#
#
dev(a=x1, r=x2, N=N, x=x)#
# -3.216395#
#
dev(a=deathRate/birthRate, r=birthRate-deathRate, N=N, x=x)#
# -3.216395#
#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
#
birthRate = 0.222222222222#
dev(a=0/birthRate, r=birthRate-0, N=N, x=x)#
S <- rep(1, times=length(tr$tip.label))#
bd.ext(phy=tr, S=S, conditional=TRUE)#
#       d / b = 2.883955e-07   StdErr = NaN #
#       b - d = 0.2656457   StdErr = NaN #
#
bd.ext(phy=tr, S=S, conditional=FALSE) # same than older versions#
#      d / b = 4.949791e-06   StdErr = NaN #
#      b - d = 0.242636   StdErr = NaN #
########################################################
########################################################
# 3. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
yule(phy=tr)#
# $lambda#
# [1] 0.2222222#
# #
# $se#
# [1] 0.1571348#
# #
# $loglik#
# [1] -3.216395#
# #
# attr(,"class")#
# [1] "yule"#
########################################################
# Yule likelihood#
########################################################
yule_lik <- function(tr)#
	{#
	# Total length of tree#
	X <- sum(tr$edge.length)#
#
	# Number of internal nodes#
	tr$Nnode#
	# Number of internal nodes, minus root#
	nb_node <- tr$Nnode - 1#
  # ML estimate of lambda (birthrate)#
  lambda <- nb_node/X#
  # Standard error of ML estimate#
  se <- lambda/sqrt(nb_node)#
  # Log-likelihood#
  lnl_topology = lfactorial(tr$Nnode)#
  lnl_numBirths = nb_node * log(lambda)#
  loglik = -lambda * X + lnl_topology + lnl_numBirths#
  loglik#
  # -3.216395#
  res = NULL#
  res$lambda = lambda#
  res$se = se#
  res$loglik = loglik#
  return(res)#
  }#
#
yule_lik(tr=tr)#
# -3.216395 #
########################################################
########################################################
# 3. Set up of equivalent BiSSE model for DEC, starting values#
########################################################
########################################################
#
# ClaSSE helper functions#
library(diversitree)#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")#
###################################################
# Set up states for BiSSE to match DEC states#
###################################################
#
# States in the BiSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
#states = c(1, 1, 1, 1)#
states = c(0, 1, 1) # 3 states for 3 tips#
names(states) = tr$tip.label#
states#
# Proportion of species in each state; for 2 states#
# (Let's assume we have all species)#
sampling.f = c(1,1)  # length(sampling.f) = 2 states#
#
# Number of states#
k = 2#
#
# Make the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
bisse_2areas = diversitree::make.bisse(tree=tr, states=states, sampling.f=sampling.f, strict=FALSE)#
#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
birthRate = 0.222222222#
deathRate = 1.2#
#
lambda0 = birthRate*2#
lambda1 = birthRate#
mu0 = deathRate#
mu1 = deathRate*2#
q01 = 0.4#
q10 = 0.2#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
bisse_params = parms#
#
# Constraint parameters so you are only fitting 1 birthRate#
# constraints = list(lambda0~lambda1, mu0~mu1, q01~q10)#
# bisse_2areas_constrained = constrain(f=bisse_2areas, formulae=constraints)#
# #
# Wait 1 seconds#
# fit <- find.mle(func=bisse_2areas_constrained, x.init=bisse_params, method="subplex")#
# fit$par.full#
# fit$lnLik#
# #
# Compare to Yule#
# yule(tr)#
# #
# bisse_params_orig = bisse_params#
# bisse_params = fit$par.full#
#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 3-4 sum to 1#
rowSums(base[,3:4])#
#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
########################################################
########################################################
# 5. BiSSE likelihoods and comparison to yule#
########################################################
########################################################
birthRate#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
#
bisse_params = parms#
#
# Starting values of state variables#
E0t = 0#
E1t = 0#
D0t = 0#
D1t = 1#
y = c(E0t, E1t, D0t, D1t)#
names(y) = c("E0t", "E1t", "D0t", "D1t")#
y#
#
# t = current time point of integration#
# y = state variable we are tracking (named)  MUST HAVE NAMES!!!#
# parms = model parameters (named)            MUST HAVE NAMES!!!#
#
define_BiSSE_eqns_in_R <- function(t, y, parms)#
	{#
	with(data=#
	as.list(c(y, parms)), #
		{ # expr#
		# When the limit is taken as deltaT goes to 0, the#
		# change in E0 in dt is:#
		# probs of: #
		# - extinction#
		# - no change but later extinction#
		# - state change, then extinction#
		# - no change, speciation, extinction of both#
		dE0t <- mu0 - (mu0 + q01 + lambda0)*E0t + q01*E1t + lambda0*(E0t)^2#
		dE1t <- mu1 - (mu1 + q10 + lambda1)*E1t + q10*E0t + lambda1*(E1t)^2#
#
		# probs of:#
		# - no change#
		# - character change, no speciation#
		# - speciation followed by extinction of 1#
		# - extinction (prob of observed clade = 0, since the clade is extant)#
		dD0t <- -1*(lambda0 + mu0 + q01)*D0t + q01*D1t + 2*lambda0*E0t*D0t + 0#
		dD1t <- -1*(lambda1 + mu1 + q10)*D1t + q10*D0t + 2*lambda1*E1t*D1t + 0#
#
		# Return the list of coupled differential equations#
		res <- c(dE0t, dE1t, dD0t, dD1t)#
		return(list(res))#
		#return(list_of_diff_eqns)#
		}#
	)#
	}#
#
# One step test:#
one_step_result = define_BiSSE_eqns_in_R(t=t, y=y, parms=parms)#
one_step_result#
# [[1]]#
# [1]  0.0000000  0.0000000  0.0000000 -0.2222222#
#
# LSODA inputs:#
# y = initial state values#
# times = times at which you want estimates#
# func#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
out#
#
parms2 = parms#
parms2["mu0"] = 0.1#
parms2["mu1"] = 0.1#
times = seq(0,1,1/50)#
out <- lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms2) #
out#
# Downpass#
numsteps = 100000#
numstates = 2#
num_internal_nodes = tr$Nnode#
numtips = length(tr$tip.label)#
num_internal_nodes = tr$Nnode#
numnodes = numtips + num_internal_nodes#
tipnums <- 1:numtips#
# Reorder the edge matrix into pruningwise order#
# This is CRUCIAL!!#
tr2 <- reorder(tr, "pruningwise")#
edgelengths = tr2$edge.length#
# Define matrices to store data#
# We have Es for each state, and Ds for each state#
# But we only need to record the Ds#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Fill in the likelihoods of tip nodes manually#
#tip_states_Ds = y[c(((length(y)/2)+1), length(y))]#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[1,numstates] = 1	# chimp#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[2,1] = 1	# human#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE[3,numstates] = 1	# gorilla#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang if a different state#
# condlikes_of_each_treeState_BRANCHTOP_AT_NODE[4,numstates] = 1	# orang same states for all tips#
#
zeros = matrix(data=0, nrow=numnodes, ncol=numstates)#
condlikes_of_each_treeState_BRANCHTOP_AT_NODE = cbind(zeros, condlikes_of_each_treeState_BRANCHTOP_AT_NODE)#
condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
#
relative_probs_of_each_state_BRANCHTOP_AT_NODE = condlikes_of_each_treeState_BRANCHTOP_AT_NODE[,3:4]#
relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] = relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,] / rowSums(relative_probs_of_each_state_BRANCHTOP_AT_NODE[1:numtips,])#
#
relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates)#
#
# Store both the Es and the Ds likelihoods#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS = condlikes_of_each_treeState_BRANCHTOP_AT_NODE#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS = matrix(data=0, nrow=numnodes, ncol=numstates*2)#
#
computed_likelihoods_at_each_node = rep(0, numnodes)#
computed_likelihoods_at_each_node[1:numtips] = 1#
computed_likelihoods_at_each_node_x_lambda = computed_likelihoods_at_each_node#
# DEFINE DOWNPASS THROUGH THE BRANCHES	#
i = 1#
edges_to_visit = seq(from=1, by=2, length.out=num_internal_nodes)#
#
# Speciation#
lambda0 = bisse_params["lambda0"]#
lambda1 = bisse_params["lambda1"]#
# Extinction#
mu0 = bisse_params["mu0"]#
mu1 = bisse_params["mu1"]#
# Character transition#
q01 = bisse_params["q01"]#
q10 = bisse_params["q10"]#
#
parms = c(lambda0, lambda1, mu0, mu1, q01, q10)#
names(parms) = c("lambda0", "lambda1", "mu0", "mu1", "q01", "q10")#
parms#
numsteps=100#
#
names_y = c("E0t", "E1t", "D0t", "D1t")#
#
i = 1#
for (i in edges_to_visit)#
	{#
	# First edge visited is i#
	#print(i)#
	# Its sister is j #
	j <- i + 1#
#
	# Get the node numbers at the tips of these two edges		#
	left_desc_nodenum <- tr2$edge[i, 2]#
	right_desc_nodenum <- tr2$edge[j, 2]#
	left_edgenum_TF = tr2$edge[, 2] == left_desc_nodenum#
	right_edgenum_TF = tr2$edge[, 2] == right_desc_nodenum#
	left_edgenum = (1:length(edgelengths))[left_edgenum_TF]#
	right_edgenum = (1:length(edgelengths))[right_edgenum_TF]#
	# And for the ancestor edge (i or j shouldn't matter, should produce the same result!!!)#
	anc <- tr2$edge[i, 1]#
	# Calculate the downpass on two branches#
	# The Es are 0 (no extinctions above, already accounted for)#
	# Left branch#
	# The Ds are relative state probabilities#
	edgelength_Left = edgelengths[left_edgenum]#
	times = seq(from=0, to=edgelength_Left, by=edgelength_Left/numsteps)#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[left_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixL = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempLeft = out_matrixL[nrow(out_matrixL),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = condlikes_tempLeft#
	condExtinct_Left = condlikes_tempLeft[1:2]#
	condlikes_Left = condlikes_tempLeft[3:4]#
#
	# #
	# R, 100 steps, mu=0#
	# 100 1.00   0   0 0.7687171 0.0338017454#
	# HiSSE, 2 steps, tiny mu#
	# 2    1 1.992624e-07 1.992624e-07 0.7666849 0.03405248#
	# HiSSE, 100 steps#
	# 100 1.00 1.974810e-07 1.974810e-07 0.7687171 0.0338017546#
	# Right branch#
	edgelength_Right = edgelengths[right_edgenum]#
	times = seq(from=0, to=edgelength_Right, by=edgelength_Right/numsteps)#
	# The Ds are relative state probabilities#
	y = condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[right_desc_nodenum,]#
	names(y) = names_y#
#
	out_matrixR = lsoda(y=y, times=times, func=define_BiSSE_eqns_in_R, parms=parms) #
	condlikes_tempRight = out_matrixR[nrow(out_matrixR),][2:5]#
	condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = condlikes_tempRight#
	condExtinct_Right = condlikes_tempRight[1:2]#
	condlikes_Right = condlikes_tempRight[3:4]#
	# Conditional likelihoods of states at the bottom of right branch#
	#condlikes_Right = independent_likelihoods_on_each_branch[[j]] %*% relative_probs_of_each_state_BRANCHTOP_AT_NODE[right_desc_nodenum,]#
	# Every node (except maybe the root) has a branch below it, and there is also a #
	# relative_probs_of_each_state_BRANCHTOP_AT_NODE at the bottom of this branch#
	condprobs_Left = condlikes_Left / sum(condlikes_Left)#
	condprobs_Right = condlikes_Right / sum(condlikes_Right)#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] = condprobs_Left#
	relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,] = condprobs_Right#
	# If there is no speciational model, you are assuming 100% sympatry (range duplication)#
	# at each speciation event#
	##
	# In this case, you can just multiply the two conditional likelihood matrices together#
	##
	# Also, if a branch is extremely short (a "hook"), this is essentially a zero-length#
	# branch, we are assuming that this represents the range of a lineage at that #
	# point.  There is no speciation event here -- both "lineages" inherit#
	# the same range.  This allows fossils to closely influence ancestral states.#
	##
	# This was developed with Kaitlin Maguire over several years of screwing around.#
#
	# Check for a short "hook" branch; if found, use just allopatric speciational model#
#
	# get the correct edge#
	left_edge_TF = tr2$edge[,2] == left_desc_nodenum#
	right_edge_TF = tr2$edge[,2] == right_desc_nodenum#
	node_likelihood = condlikes_Left * condlikes_Right#
	lambda0 = parms["lambda0"]#
	lambda1 = parms["lambda1"]#
	node_likelihood_x_lambda = node_likelihood * c(lambda0, lambda1)#
	E_average = colMeans(rbind(condExtinct_Left, condExtinct_Right))#
	# birthRate*base[1,3:4]^2#
	D_relprobs_multiplied = relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[left_desc_nodenum,] * relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS[right_desc_nodenum,]#
	D_combined = c(lambda0, lambda1) * D_relprobs_multiplied#
#
	# Store the various options#
	condlikes_of_each_treeState_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood)#
	condlikes_of_each_treeState_x_lambda_BRANCHTOP_AT_NODE[anc,] = c(E_average, node_likelihood_x_lambda)#
	condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS[anc, ] = c(E_average, D_combined)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[left_desc_nodenum,] = c(E_average, condprobs_Left)#
	condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[right_desc_nodenum,] = c(E_average, condprobs_Right)#
	# node_likelihood_x_lambda#
	#          D0t          D1t #
    # 0.1313168545 0.0002539018 #
# 	> v*c(0.333333, 0.333333)#
# 			  D0           D1 #
# 	0.1306233807 0.0002576823 #
# 	> v#
# 			 D0          D1 #
# 	0.587805801 0.001159572 #
# 	>  sequence(length(desRows))#
# 	[1] 1 2#
# 	> compD[focal,]#
# 	[1] 0.1306233895 0.0002576823#
	total_likelihood_for_node = sum(node_likelihood)#
	total_likelihood_for_node_x_lambda = sum(node_likelihood_x_lambda)#
	computed_likelihoods_at_each_node[anc] = total_likelihood_for_node#
	computed_likelihoods_at_each_node_x_lambda[anc] = sum(total_likelihood_for_node_x_lambda)#
	#print(total_likelihood_for_node)#
	relative_probs_of_each_state_BRANCHTOP_AT_NODE[anc, ] = node_likelihood_x_lambda / total_likelihood_for_node_x_lambda#
	} # END for (i in edges_to_visit)#
########################################################
########################################################
# START PROOF OF MATCHING THIS CODE TO DIVERSITREE#
########################################################
########################################################
# Best, matches diversitree BiSSE "init"#
init#
#           [,1]      [,2]      [,3]        [,4]#
# [1,] 0.0000000 0.0000000 1.0000000 0.000000000#
# [2,] 0.0000000 0.0000000 0.0000000 1.000000000#
# [3,] 0.0000000 0.0000000 0.0000000 1.000000000#
# [4,] 0.8988459 0.9775416 0.2597286 0.009541766#
# [5,] 0.6888798 0.8799765 0.1518462 0.015528271#
condlikes_treeStates_BRANCHTOP_AT_NODE_DOWNPASS#
#           [,1]      [,2]       [,3]       [,4]#
# [1,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [2,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [3,] 0.0000000 0.0000000 0.00000000 1.00000000#
# [4,] 0.8988459 0.9775416 0.20907825 0.02186927#
# [5,] 0.6888798 0.8799766 0.06604511 0.08391649#
# Matches matches diversitree BiSSE "base" -- but a weird combination of #
# - left columns: average E's passed down#
# - right columns: normalized conditional likelihoods#
base#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]      [,3]      [,4]#
# [1,] 0.6888798 0.8799765 0.8862882 0.1137118#
# [2,] 0.6888798 0.8799765 0.3854885 0.6145115#
# [3,] 0.8988459 0.9775416 0.6725996 0.3274004#
# [4,]        NA        NA        NA        NA#
# [5,] 0.8988459 0.9775416 0.8688519 0.1311481#
condlikesProbs_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]      [,3]      [,4]#
# [1,] 0.6888798 0.8799766 0.3854886 0.6145114#
# [2,] 0.6888798 0.8799766 0.3854886 0.6145114#
# [3,] 0.8988459 0.9775416 0.6725994 0.3274006#
# [4,] 0.0000000 0.0000000 0.0000000 0.0000000#
# [5,] 0.8988459 0.9775416 0.6994149 0.3005851#
# lq and likelihoods#
condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS#
#           [,1]      [,2]       [,3]        [,4]#
# [1,] 0.6888798 0.8799766 0.05141641 0.081963417#
# [2,] 0.6888798 0.8799766 0.05141641 0.081963417#
# [3,] 0.8988459 0.9775416 0.01959357 0.009537547#
# [4,] 0.0000000 0.0000000 0.00000000 0.000000000#
# [5,] 0.8988459 0.9775416 0.02373981 0.010202572#
#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(condlikes_treeStates_BRANCHBOTTOM_BELOW_NODE_DOWNPASS[,3:4]))#
lnls[!is.finite(lnls)] = NA#
lnls#
sum(lnls, na.rm=TRUE)#
# -1.526391 -2.014554 -3.535949  0.000000 -3.012482#
sum(lnls, na.rm=TRUE)#
# -10.08938#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -1.526391 -2.014554 -3.535949  0.000000 -3.012482#
# -10.08938#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# -11.47222 -10.08938#
#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# -6.043899 -10.089376#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(computed_likelihoods_at_each_node_x_lambda))#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
# -14.31109#
R_result_branch_lnL = -10.08938#
R_result_total_LnLs1 = -11.47222#
R_result_total_LnLs1t = -6.043899#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = -14.31109#
########################################################
########################################################
# END PROOF OF MATCHING
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.4#
d_val = 0.0#
e_val = 0.0#
j_val = 0.1#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)#
# -5.085475#
res = res1#
claSSE_res_to_prt(res1, tr, classe_params)
classe_lambdas_to_df(classe_params, k=3)
sum(classe_lambdas_to_df(classe_params, k=3)$lambda)
########################################################
# Compare ClaSSE and BiSSE calculations#
##
# E.g.:#
# diversitree versus plain-R#
# diversitree versus BioGeoBEARS+Yule+BFs#
# #
########################################################
#
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.0#
e_val = 0.0#
j_val = 0.1#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)#
# -5.085475#
res = res1#
claSSE_res_to_prt(res1, tr, classe_params)
########################################################
# Compare ClaSSE and BiSSE calculations#
##
# E.g.:#
# diversitree versus plain-R#
# diversitree versus BioGeoBEARS+Yule+BFs#
# #
########################################################
#
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.0#
e_val = 0.0#
j_val = 0.0#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)
classe_lambdas_to_df(classe_params=classe_params, k=3)
########################################################
# Compare ClaSSE and BiSSE calculations#
##
# E.g.:#
# diversitree versus plain-R#
# diversitree versus BioGeoBEARS+Yule+BFs#
# #
########################################################
#
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.0#
e_val = 0.0#
j_val = 0.0#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)
init
base
base * exp(lq)
base * exp(lq)
lq
base * t(exp(lq))
base * c(exp(lq))
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.0#
e_val = 0.0#
j_val = 0.1#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.0#
e_val = 0.0#
j_val = 0.1#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)#
# -5.085475#
res = res1#
claSSE_res_to_prt(res1, tr, classe_params)#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
# -4.748244#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# -8.170992 -4.748244#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# -6.228375 -4.748244#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
computed_likelihoods_at_each_node_x_lambda = rep(0.0, times=tr$Nnode + length(tr$tip.label))#
likes_at_node5 = rep(0.0, times=ncol(base_likes))#
likes_at_node4 = rep(0.0, times=ncol(base_likes))#
#
# Internal node#
state_i = 1#
likes_at_node5[state_i] = sum(base_normlikes[1,state_i] * base_normlikes[2,state_i] * birthRate) # sympatry#
state_i = 2#
likes_at_node5[state_i] = sum(base_normlikes[1,state_i] * base_normlikes[2,state_i] * birthRate) # sympatry#
state_i = 3#
likes_at_node5[state_i] = sum(base_normlikes[1,2] * base_normlikes[2,1] * 1/6*birthRate) # vicariance#
# Add small probs for subset sympatry#
likes_at_node5[state_i] = likes_at_node5[state_i] + sum(base_normlikes[1,2] * base_normlikes[2,3] * 1/6*birthRate)#
likes_at_node5[state_i] = likes_at_node5[state_i] + sum(base_normlikes[2,1] * base_normlikes[1,3] * 1/6*birthRate)#
likes_at_node5#
#
# Root node#
state_i = 1#
likes_at_node4[state_i] = sum(base_normlikes[3,state_i] * base_normlikes[5,state_i] * birthRate) # sympatry#
state_i = 2#
likes_at_node4[state_i] = sum(base_normlikes[3,state_i] * base_normlikes[5,state_i] * birthRate) # sympatry#
state_i = 3#
likes_at_node4[state_i] = sum(base_normlikes[3,2] * base_normlikes[5,3] * 1/6*birthRate) # subset sympatry#
likes_at_node4#
computed_likelihoods_at_each_node_just_before_speciation = get_sum_log_computed_likes_at_each_node(tr, base, lq, classe_params)#
computed_likelihoods_at_each_node_just_before_speciation#
rowSums(computed_likelihoods_at_each_node_just_before_speciation)#
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))#
TF = is.finite(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)))#
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))
computed_likelihoods_at_each_node_x_lambda = rep(0.0, times=tr$Nnode + length(tr$tip.label))#
#
computed_likelihoods_at_each_node_just_before_speciation = get_sum_log_computed_likes_at_each_node(tr, base, lq, classe_params)#
computed_likelihoods_at_each_node_just_before_speciation#
rowSums(computed_likelihoods_at_each_node_just_before_speciation)#
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))#
TF = is.finite(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)))#
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))
R_result_sum_log_computed_likelihoods_at_each_node = computed_likelihoods_at_each_node_just_before_speciation#
R_result_sum_log_computed_likelihoods_at_each_node#
log(R_result_sum_log_computed_likelihoods_at_each_node)#
sum(log(R_result_sum_log_computed_likelihoods_at_each_node))
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))
computed_likelihoods_at_each_node_just_before_speciation = get_sum_log_computed_likes_at_each_node(tr, base, lq, classe_params)#
computed_likelihoods_at_each_node_just_before_speciation#
rowSums(computed_likelihoods_at_each_node_just_before_speciation)#
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))#
TF = is.finite(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)))#
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))
computed_likelihoods_at_each_node_just_before_speciation = get_sum_log_computed_likes_at_each_node(tr, base, lq, classe_params)#
computed_likelihoods_at_each_node_just_before_speciation#
rowSums(computed_likelihoods_at_each_node_just_before_speciation)#
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))#
TF = is.finite(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)))#
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))#
R_result_sum_log_computed_likelihoods_at_each_node = sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))#
# [1] 0.00000000 0.00000000 0.00000000 0.07471615 0.06750957#
# [1]      -Inf      -Inf      -Inf -2.594059 -2.695486#
# [1] -5.289545#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = sum(log(R_result_sum_log_computed_likelihoods_at_each_node)) + sum(lq)#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
R_result_sum_log_computed_likelihoods_at_each_node
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = R_result_sum_log_computed_likelihoods_at_each_node + sum(lq)#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
lq#
sum(lq)#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
# -4.748244#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# -8.170992 -4.748244#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t
########################################################
# Compare ClaSSE and BiSSE calculations#
##
# E.g.:#
# diversitree versus plain-R#
# diversitree versus BioGeoBEARS+Yule+BFs#
# #
########################################################
#
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 0.1#
d_val = 0.5#
e_val = 0.4#
j_val = 0.1#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)#
# -5.085475#
res = res1#
claSSE_res_to_prt(res1, tr, classe_params)#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# [1,] -0.2757956 -0.2757956 -0.511628    0 -2.954491#
# [1] -4.01771#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# [1] -7.337335 -4.017710#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# -5.394719 -4.017710#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
computed_likelihoods_at_each_node_x_lambda = rep(0.0, times=tr$Nnode + length(tr$tip.label))#
#
computed_likelihoods_at_each_node_just_before_speciation = get_sum_log_computed_likes_at_each_node(tr, base, lq, classe_params)#
computed_likelihoods_at_each_node_just_before_speciation#
rowSums(computed_likelihoods_at_each_node_just_before_speciation)#
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))#
TF = is.finite(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)))#
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))#
R_result_sum_log_computed_likelihoods_at_each_node = sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))#
# [1] 0.00000000 0.00000000 0.00000000 0.07471615 0.06750957#
# [1]      -Inf      -Inf      -Inf -2.594059 -2.695486#
# [1] -5.289545#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = R_result_sum_log_computed_likelihoods_at_each_node + sum(lq)#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda
########################################################
# Compare ClaSSE and BiSSE calculations#
##
# E.g.:#
# diversitree versus plain-R#
# diversitree versus BioGeoBEARS+Yule+BFs#
# #
########################################################
#
library(ape)#
library(diversitree)#
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_functions_v3.R")  # utility functions from diversitree#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_pureR_v1.R") # simple implementations in plain-R#
source("/GitHub/BioGeoJulia.jl/Rsrc/ClaSSE_mods_v2.R") # simple implementations in plain-R#
# Load simple example tree#
wd = "/GitHub/BioGeoJulia.jl/Rsrc/"#
setwd(wd)#
trfn = "tree_small.newick"#
tr = read.tree(trfn)#
#
trstr = "((chimp:1,human:1):1,gorilla:2);"#
tr = read.tree(file="", text=trstr)#
#
# Run a BiSSE model from diversitree#
#
# Setup#
states = c(2,1,2)		# Tip states#
names(states) = tr$tip.label#
states#
#
sampling.f = c(1,1,1)		# Proportion of species in each state; for 2 states#
											# (Let's assume we have all species)#
k = length(sampling.f)#
#
# Create the BiSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_3states = make.classe(tree=tr, states=states, k=k, sampling.f=sampling.f, strict=FALSE)#
#
# Input some parameters#
birthRate = 0.2#
deathRate = 1.0#
d_val = 0.5#
e_val = 0.4#
j_val = 1.5#
#
# The names of the parameters:#
param_names = argnames(classe_3states)#
param_names#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
# This is basically a DEC model for 3 states#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
#classe_params[grepl(pattern="lambda", x=param_names)] = birthRate#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
classe_params[grepl(pattern="q", x=param_names)] = 0#
#
# For DEC#
classe_params[param_names == "q31"] = e_val#
classe_params[param_names == "q32"] = e_val#
classe_params[param_names == "q13"] = d_val#
classe_params[param_names == "q23"] = d_val#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda111"] = yprob * birthRate#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = 0#
#
# Jump dispersal speciation#
# We do x2, because lambda112 covers lambda121#
classe_params[param_names=="lambda112"] = jprob * birthRate * 2#
classe_params[param_names=="lambda121"] = jprob * birthRate * 2#
classe_params[param_names=="lambda212"] = jprob * birthRate * 2#
classe_params[param_names=="lambda221"] = jprob * birthRate * 2#
#
# Vicariance etc. -- still just 1/6 as there are #
# no j events from AB in a 2-area system#
# We do x2, because lambda312 covers lambda321#
classe_params[param_names=="lambda312"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda321"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda313"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda331"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda323"] = 1/6 * birthRate * 2#
classe_params[param_names=="lambda332"] = 1/6 * birthRate * 2#
#
# For diversitree ClaSSE, you have to lump lambda312 and lambda321#
# classe_params[param_names=="lambda312"] = 1/3 * birthRate#
# classe_params[param_names=="lambda313"] = 1/3 * birthRate#
# classe_params[param_names=="lambda323"] = 1/3 * birthRate#
classe_lambdas_to_df(classe_params, k=3)#
#
classe_params_DEC = classe_params#
classe_lambdas_to_df(classe_params, k=3)#
#
# To see the function:#
dput(classe_3states)#
#
classe_3states_default <- function(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL, intermediates=FALSE) #
	{#
	## Note that this uses MuSSE's cache...#
	pars2 <- f.pars(pars)#
	ans <- all.branches(pars2, intermediates)#
	ans$branchLnL = sum(ans$lq)#
	rootfunc.classe(ans, pars, condition.surv, root, root.p, intermediates)#
	}#
# Do the ClaSSE calculation, under many different assumptions#
res1 = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1, 0.1, 0.8)#
res4 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 0, 1)#
res5 = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
res1t = classe_3states(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = classe_3states(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.3333333, 0.3333333, 0.3333333)#
res3t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1, 0.1, 0.8)#
res4t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 0, 1)#
res5t = classe_3states(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = classe_3states(pars=classe_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
init = t(attr(res2, "intermediates")$init)#
init#
#
lq = t(attr(res2, "intermediates")$lq)#
lq#
#
base = t(attr(res2, "intermediates")$base)#
base#
base_likes = apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
base_normlikes = base_likes / rowSums(base_likes)#
# Matches diversitree BiSSE "lq"#
lnls = log(rowSums(base_likes))#
lnls[!is.finite(lnls)] = NA#
lnls#
# -0.2757956 -0.2757956 -0.5116280         NA -3.6850244#
sum(lnls, na.rm=TRUE)#
# -5.085475#
res = res1#
claSSE_res_to_prt(res1, tr, classe_params)#
# Sum of the branch likelihoods#
lq#
sum(lq)#
# [1,] -0.3363707 -0.3363707 -0.6011676    0 -3.048724#
# [1] -4.322633#
#
# Add the root probabilities#
# Assuming diversitree options:#
# root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
# i.e., the root state probs are just the root_Ds/sum(root_Ds)#
LnLs1#
# [1] -8.008731 -4.322633#
# root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
LnLs1t#
# [1] -6.066114 -4.322633#
#
# Does the total of branch likelihoods (lq) + node likelihoods match R?#
computed_likelihoods_at_each_node_x_lambda = rep(0.0, times=tr$Nnode + length(tr$tip.label))#
#
computed_likelihoods_at_each_node_just_before_speciation = get_sum_log_computed_likes_at_each_node(tr, base, lq, classe_params)#
computed_likelihoods_at_each_node_just_before_speciation#
rowSums(computed_likelihoods_at_each_node_just_before_speciation)#
log(rowSums(computed_likelihoods_at_each_node_just_before_speciation))#
TF = is.finite(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)))#
sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))#
R_result_sum_log_computed_likelihoods_at_each_node = sum(log(rowSums(computed_likelihoods_at_each_node_just_before_speciation)[TF]))#
# [1] 0.00000000 0.00000000 0.00000000 0.06581332 0.05975440#
# [1]      -Inf      -Inf      -Inf -2.720933 -2.817512#
# [1] -5.538445#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = R_result_sum_log_computed_likelihoods_at_each_node + sum(lq)#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
# -9.861079#
R_result_branch_lnL = -4.322633#
R_result_total_LnLs1 = -8.008731#
R_result_total_LnLs1t = -6.066114#
R_result_sum_log_computed_likelihoods_at_each_node_x_lambda = -9.861079#
# Key parts of the calculation#
lq = t(attr(res2, "intermediates")$lq)			# Branch likelihoods#
vals = t(attr(res2, "intermediates")$vals)	# Es and Ds at the root#
nstates = length(vals) / 2#
E_indices = 1:nstates#
d_root_orig = vals[-E_indices]							# Original D likelihoods at root#
#
# If root=ROOT.OBS, root.p=NULL, condition.surv=FALSE#
root.p = d_root_orig/sum(d_root_orig)#
loglik = log(sum(root.p * d_root_orig)) + sum(lq)#
loglik#
#
# If root=ROOT.FLAT, root.p=NULL, condition.surv=FALSE#
root.p = rep(1/nstates, times=nstates)#
loglik = log(sum(root.p * d_root_orig)) + sum(lq)#
loglik#
#
# If root=ROOT.GIVEN, root.p=c(0.5,0.5), condition.surv=FALSE#
root.p = c(0.3333333, 0.3333333, 0.3333333)#
loglik = log(sum(root.p * d_root_orig)) + sum(lq)#
loglik#
#
# If root=ROOT.GIVEN, root.p=c(0.75,0.25), condition.surv=FALSE#
root.p = c(0.1, 0.1, 0.8)#
loglik = log(sum(root.p * d_root_orig)) + sum(lq)#
loglik#
#
# If root=ROOT.GIVEN, root.p=c(0.5,0.5), condition.surv=FALSE#
root.p = c(0, 0, 1)#
loglik = log(sum(root.p * d_root_orig)) + sum(lq)#
loglik#
#
# If root=ROOT.EQUI, condition.surv=FALSE#
#
# Project the ClaSSE model onto an instantaneous rate matrix, A#
A = projection.matrix.classe(pars=classe_params, k) #
#
# Calculate equilibrium frequencies by eigenvectors#
evA <- eigen(A)#
i <- which(evA$values == max(evA$values))#
equilibrium_root_freqs = evA$vectors[, i]/sum(evA$vectors[, i])#
equilibrium_root_freqs#
# 0.2652666 0.2285983 0.2285983 0.2775368#
#
loglik = log(sum(equilibrium_root_freqs * d_root_orig)) + sum(lq)#
loglik#
# -12.269765 matches!#
# If root=ROOT.OBS, root.p=NULL, condition.surv=TRUE#
root.p = d_root_orig/sum(d_root_orig)#
#lambda <- classe_params[E_indices]#
e.root <- vals[E_indices]#
#
# BiSSE#
#d.root <- d_root_orig/sum(root.p * lambda * (1 - e.root)^2)#
#
# MuSSE/ClaSSE#
pars = classe_params#
nsum <- k * (k + 1)/2#
lambda <- colSums(matrix(pars[1:(nsum * k)], nrow = nsum))#
i <- seq_len(k)#
e.root <- vals[i]#
d.root <- d_root_orig/sum(root.p * lambda * (1 - e.root)^2)#
#
loglik = log(sum(root.p * d.root)) + sum(lq)#
loglik#
#
# If root=ROOT.FLAT, root.p=NULL, condition.surv=TRUE#
root.p = rep(1/nstates, times=nstates)#
pars = classe_params#
nsum <- k * (k + 1)/2#
lambda <- colSums(matrix(pars[1:(nsum * k)], nrow = nsum))#
i <- seq_len(k)#
e.root <- vals[i]#
d.root <- d_root_orig/sum(root.p * lambda * (1 - e.root)^2)#
loglik = log(sum(root.p * d.root)) + sum(lq)#
loglik#
#
# If root=ROOT.GIVEN, root.p=c(0.5,0.5), condition.surv=TRUE#
root.p = c(0.3333333, 0.3333333, 0.3333333)#
pars = classe_params#
nsum <- k * (k + 1)/2#
lambda <- colSums(matrix(pars[1:(nsum * k)], nrow = nsum))#
i <- seq_len(k)#
e.root <- vals[i]#
d.root <- d_root_orig/sum(root.p * lambda * (1 - e.root)^2)#
loglik = log(sum(root.p * d.root)) + sum(lq)#
loglik#
#
# If root=ROOT.GIVEN, root.p=c(0.75,0.25), condition.surv=TRUE#
root.p = c(0.1, 0.1, 0.8)#
pars = classe_params#
nsum <- k * (k + 1)/2#
lambda <- colSums(matrix(pars[1:(nsum * k)], nrow = nsum))#
i <- seq_len(k)#
e.root <- vals[i]#
d.root <- d_root_orig/sum(root.p * lambda * (1 - e.root)^2)#
loglik = log(sum(root.p * d.root)) + sum(lq)#
loglik#
#
# If root=ROOT.GIVEN, root.p=c(0.5,0.5), condition.surv=TRUE#
root.p = c(0, 0, 1)#
pars = classe_params#
nsum <- k * (k + 1)/2#
lambda <- colSums(matrix(pars[1:(nsum * k)], nrow = nsum))#
i <- seq_len(k)#
e.root <- vals[i]#
d.root <- d_root_orig/sum(root.p * lambda * (1 - e.root)^2)#
loglik = log(sum(root.p * d.root)) + sum(lq)#
loglik#
yule(tr)$loglik - log(birthRate)#
# If root=ROOT.EQUI, condition.surv=TRUE#
#
# Project the ClaSSE model onto an instantaneous rate matrix, A#
A = projection.matrix.classe(pars=classe_params, k) #
#
# Calculate equilibrium frequencies by eigenvectors#
evA <- eigen(A)#
i <- which(evA$values == max(evA$values))#
equilibrium_root_freqs = evA$vectors[, i]/sum(evA$vectors[, i])#
equilibrium_root_freqs#
# 0.2652666 0.2285983 0.2285983 0.2775368#
#
pars = classe_params#
nsum <- k * (k + 1)/2#
lambda <- colSums(matrix(pars[1:(nsum * k)], nrow = nsum))#
i <- seq_len(k)#
e.root <- vals[i]#
d.root <- d_root_orig/sum(equilibrium_root_freqs * lambda * (1 - e.root)^2)#
loglik = log(sum(equilibrium_root_freqs * d.root)) + sum(lq)#
loglik#
# -12.94599 matches!#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
#
apply(X=base[,4:6], MARGIN=2, FUN="*", exp(lq))#
#
# Get Es,Ds matrix#
Dindexes = (nstates+1):(nstates*2)#
EsDs_branch_bottoms = base#
EsDs_branch_bottoms[,Dindexes] = EsDs_branch_bottoms[,Dindexes] * exp(attr(res2, "intermediates")$lq)#
EsDs_branch_bottoms[1,]#
# Yay! Figured it out!#
#
projection.matrix.classe <- function(pars, k) #
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
init = t(attr(res2, "intermediates")$init)#
init#
#
base = t(attr(res2, "intermediates")$base)#
base#
# Columns 4-6, the Ds, sum to 1#
rowSums(base[,4:6])#
lq = attr(res2, "intermediates")$lq#
lq#
sum(lq)#
#
rowSums(base[,4:6]) * exp(lq)#
base[,4] * exp(lq)#
base[,5] * exp(lq)#
base[,6] * exp(lq)
